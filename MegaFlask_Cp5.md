[blog.miguelgrinberg.com](http://blog.miguelgrinberg.com "blog.miguelgrinberg.com")

# Мега-Учебник Flask, Часть 5: Пользовательские логины #
### *Miguel Grinberg* ###

----

Эта статья является переводом пятой части нового издания учебника Мигеля Гринберга. [Прежний перевод](https://habrahabr.ru/post/193242/ "Прежний перевод") давно утратил свою актуальность. 

Автор планирует завершить его выпуск в мае 2018. Я, со своей стороны, постараюсь не отставать с переводом.

<cut />
Это пятый выпуск серии Flask Mega-Tutorial, в котором я расскажу вам, как создать подсистему входа пользователя.

Для справки ниже приведен список статей этой серии.

- **Глава 1: Привет, мир!**
- **Глава 2: Шаблоны**
- **Глава 3: Веб-формы**
- **Глава 4: База данных**
- **Глава 5: Пользовательские логины (Эта статья)**
- Глава 6: Страница профиля и аватары (доступно 9 января 2018 года)
- Глава 7: Обработка ошибок (доступно 16 января 2018 года)
- Глава 8: Подписчики, контакты и друзья (доступны 23 января 2018 года)
- Глава 9: Разбивка на страницы (доступна 30 января 2018 года)
- Глава 10: Поддержка электронной почты (доступна 6 февраля 2018 года)
- Глава 11: Реконструкция (доступна 13 февраля 2018 года)
- Глава 12: Дата и время (доступно 20 февраля 2018 года)
- Глава 13: I18n и L10n (доступно 27 февраля 2018 года)
- Глава 14: Ajax (доступно 6 марта 2018 года)
- Глава 15: Улучшение структуры приложения (доступно 13 марта 2018 года)
- Глава 16: Полнотекстовый поиск (доступен 20 марта 2018 года)
- Глава 17: Развертывание в Linux (доступно 27 марта 2018 года)
- Глава 18: Развертывание на Heroku (доступно 3 апреля 2018 года)
- Глава 19: Развертывание на Docker контейнерах (доступно 10 апреля 2018 года)
- Глава 20: Магия JavaScript (доступна 17 апреля 2018 года)
- Глава 21: Уведомления пользователей (доступно 24 апреля 2018 года)
- Глава 22: Справочные задания (доступны 1 мая 2018 года)
- Глава 23: Интерфейсы прикладного программирования (API) (доступно 8 мая 2018 г.)

*Примечание 1: Если вы ищете старые версии данного курса, это [здесь](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy "здесь").*

*Примечание 2: Если вдруг Вы хотели бы выступить в поддержку моей(Мигеля) работы в этом блоге, или просто не имеете терпения дожидаться неделю статьи, я (Мигель Гринберг)предлагаю полную версию данного руководства упакованную электронную книгу или видео. Для получения более подробной информации посетите [learn.miguelgrinberg.com](http://learn.miguelgrinberg.com "learn.miguelgrinberg.com").*

В **главе 3** вы узнали, как создать форму входа пользователя, а в **главе 4** вы узнали, как работать с базой данных. В этой главе вы узнаете, как объединить темы из этих двух глав, чтобы создать простую систему входа пользователя.

*Ссылки GitHub для этой главы:*  [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.5), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.5.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.4...v0.5).

## Хеширование паролей ##

В **главе 4** пользовательской модели было присвоено поле `password_hash`, которое пока не используется. Цель этого поля - сохранить хэш пароля пользователя, который будет использоваться для проверки пароля, введенного пользователем во время процесса регистрации. Хеширование паролей ( *Password hashing* ) - это сложная тема, которую следует оставить экспертам по безопасности, но есть несколько простых в использовании библиотек, которые реализуют всю эту логику таким образом, чтобы ее можно было вызвать из приложения.

Одним из пакетов, реализующих хеширование паролей, является [Werkzeug](http://http://werkzeug.pocoo.org/), который вы, возможно, видели в выводе pip при установке Flask. Раз уж это зависимость, Werkzeug уже установлен в вашей виртуальной среде. Следующий сеанс оболочки Python демонстрирует, как хешировать пароль:

    >>> from werkzeug.security import generate_password_hash
    >>> hash = generate_password_hash('foobar')
    >>> hash
    'pbkdf2:sha256:50000$vT9fkZM8$04dfa35c6476acf7e788a1b5b3c35e217c78dc04539d295f011f01f18cd2175f'

В этом примере пароль foobar преобразуется в длинную кодированную строку посредством серии криптографических операций, которые не имеют никакой обратной операции, что означает, что человек, получающий хешированный пароль, не сможет использовать его для получения исходного пароля. В качестве дополнительной меры, если вы будете иметь один и тот же пароль несколько раз, вы получите разные результаты, поэтому это не позволяет определить, имеют ли два пользователя одинаковый пароль, просматривая их хэши.

Процесс проверки выполняется со второй функцией от Werkzeug следующим образом:

    >>> from werkzeug.security import check_password_hash
    >>> check_password_hash(hash, 'foobar')
    True
    >>> check_password_hash(hash, 'barfoo')
    False

Функция проверки принимает хэш-код пароля, который был ранее сгенерирован, и пароль, введенный пользователем во время входа в систему. Функция возвращает значение `True`, если пароль, предоставленный пользователем, совпадает с хешем, иначе `False`.

Вся логика хэширования пароля может быть реализована как два новых метода в пользовательской модели:
	
	from werkzeug.security import generate_password_hash, check_password_hash
	
	# ...
	
	class User(db.Model):
	    # ...
	
	    def set_password(self, password):
	        self.password_hash = generate_password_hash(password)
	
	    def check_password(self, password):
	        return check_password_hash(self.password_hash, password)

Используя эти два метода, пользовательский объект теперь может выполнять безопасную проверку пароля без необходимости хранить оригинальные пароли. Вот пример использования этих новых методов:

    >>> u = User(username='susan', email='susan@example.com')
    >>> u.set_password('mypassword')
    >>> u.check_password('anotherpassword')
    False
    >>> u.check_password('mypassword')
    True

## Введение в Flask-Login ##

