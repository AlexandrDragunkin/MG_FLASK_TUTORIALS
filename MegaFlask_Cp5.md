[blog.miguelgrinberg.com](http://blog.miguelgrinberg.com "blog.miguelgrinberg.com")

# Мега-Учебник Flask, Часть 5: Пользовательские логины #
### *Miguel Grinberg* ###

----

Эта статья является переводом пятой части нового издания учебника Мигеля Гринберга. [Прежний перевод](https://habrahabr.ru/post/193242/ "Прежний перевод") давно утратил свою актуальность. 

Автор планирует завершить его выпуск в мае 2018. Я, со своей стороны, постараюсь не отставать с переводом.

<cut />
Это пятый выпуск серии Flask Mega-Tutorial, в котором я расскажу вам, как создать подсистему входа пользователя.

Для справки ниже приведен список статей этой серии.

- **Глава 1: Привет, мир!**
- **Глава 2: Шаблоны**
- **Глава 3: Веб-формы**
- **Глава 4: База данных**
- **Глава 5: Пользовательские логины (Эта статья)**
- Глава 6: Страница профиля и аватары (доступно 9 января 2018 года)
- Глава 7: Обработка ошибок (доступно 16 января 2018 года)
- Глава 8: Подписчики, контакты и друзья (доступны 23 января 2018 года)
- Глава 9: Разбивка на страницы (доступна 30 января 2018 года)
- Глава 10: Поддержка электронной почты (доступна 6 февраля 2018 года)
- Глава 11: Реконструкция (доступна 13 февраля 2018 года)
- Глава 12: Дата и время (доступно 20 февраля 2018 года)
- Глава 13: I18n и L10n (доступно 27 февраля 2018 года)
- Глава 14: Ajax (доступно 6 марта 2018 года)
- Глава 15: Улучшение структуры приложения (доступно 13 марта 2018 года)
- Глава 16: Полнотекстовый поиск (доступен 20 марта 2018 года)
- Глава 17: Развертывание в Linux (доступно 27 марта 2018 года)
- Глава 18: Развертывание на Heroku (доступно 3 апреля 2018 года)
- Глава 19: Развертывание на Docker контейнерах (доступно 10 апреля 2018 года)
- Глава 20: Магия JavaScript (доступна 17 апреля 2018 года)
- Глава 21: Уведомления пользователей (доступно 24 апреля 2018 года)
- Глава 22: Справочные задания (доступны 1 мая 2018 года)
- Глава 23: Интерфейсы прикладного программирования (API) (доступно 8 мая 2018 г.)

*Примечание 1: Если вы ищете старые версии данного курса, это [здесь](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy "здесь").*

*Примечание 2: Если вдруг Вы хотели бы выступить в поддержку моей(Мигеля) работы в этом блоге, или просто не имеете терпения дожидаться неделю статьи, я (Мигель Гринберг)предлагаю полную версию данного руководства упакованную электронную книгу или видео. Для получения более подробной информации посетите [learn.miguelgrinberg.com](http://learn.miguelgrinberg.com "learn.miguelgrinberg.com").*

В **главе 3** вы узнали, как создать форму входа пользователя, а в **главе 4** вы узнали, как работать с базой данных. В этой главе вы узнаете, как объединить темы из этих двух глав, чтобы создать простую систему входа пользователя.

*Ссылки GitHub для этой главы:*  [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.5), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.5.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.4...v0.5).

## Хеширование паролей ##

В **главе 4** пользовательской модели было присвоено поле `password_hash`, которое пока не используется. Цель этого поля - сохранить хэш пароля пользователя, который будет использоваться для проверки пароля, введенного пользователем во время процесса регистрации. Хеширование паролей ( *Password hashing* ) - это сложная тема, которую следует оставить экспертам по безопасности, но есть несколько простых в использовании библиотек, которые реализуют всю эту логику таким образом, чтобы ее можно было вызвать из приложения.

Одним из пакетов, реализующих хеширование паролей, является [Werkzeug](http://http://werkzeug.pocoo.org/), который вы, возможно, видели в выводе pip при установке Flask. Раз уж это зависимость, Werkzeug уже установлен в вашей виртуальной среде. Следующий сеанс оболочки Python демонстрирует, как хешировать пароль:

    >>> from werkzeug.security import generate_password_hash
    >>> hash = generate_password_hash('foobar')
    >>> hash
    'pbkdf2:sha256:50000$vT9fkZM8$04dfa35c6476acf7e788a1b5b3c35e217c78dc04539d295f011f01f18cd2175f'

В этом примере пароль foobar преобразуется в длинную кодированную строку посредством серии криптографических операций, которые не имеют никакой обратной операции, что означает, что человек, получающий хешированный пароль, не сможет использовать его для получения исходного пароля. В качестве дополнительной меры, если вы будете иметь один и тот же пароль несколько раз, вы получите разные результаты, поэтому это не позволяет определить, имеют ли два пользователя одинаковый пароль, просматривая их хэши.

Процесс проверки выполняется со второй функцией от Werkzeug следующим образом:

    >>> from werkzeug.security import check_password_hash
    >>> check_password_hash(hash, 'foobar')
    True
    >>> check_password_hash(hash, 'barfoo')
    False

Функция проверки принимает хэш-код пароля, который был ранее сгенерирован, и пароль, введенный пользователем во время входа в систему. Функция возвращает значение `True`, если пароль, предоставленный пользователем, совпадает с хешем, иначе `False`.

Вся логика хэширования пароля может быть реализована как два новых метода в пользовательской модели:
	
	from werkzeug.security import generate_password_hash, check_password_hash
	
	# ...
	
	class User(db.Model):
	    # ...
	
	    def set_password(self, password):
	        self.password_hash = generate_password_hash(password)
	
	    def check_password(self, password):
	        return check_password_hash(self.password_hash, password)

Используя эти два метода, пользовательский объект теперь может выполнять безопасную проверку пароля без необходимости хранить оригинальные пароли. Вот пример использования этих новых методов:

    >>> u = User(username='susan', email='susan@example.com')
    >>> u.set_password('mypassword')
    >>> u.check_password('anotherpassword')
    False
    >>> u.check_password('mypassword')
    True

## Введение в Flask-Login ##

В этой главе я познакомлю вас с очень популярным расширением Flask под названием Flask-Login. Это расширение управляет состоянием входа пользователя в систему, так что, например, пользователи могут войти в приложение, а затем перейти на разные страницы, пока приложение «помнит», что пользователь вошел в систему. Оно также предоставляет функциональность «запомнить меня», которая позволяет пользователям оставаться в системе даже после закрытия окна браузера. Чтобы быть готовым к этой главе, вы можете начать с установки Flask-Login в вашей виртуальной среде:

    (venv) $ pip install flask-login

Как и с другими расширениями, Flask-Login должен быть создан и инициализирован сразу после экземпляра приложения в app/__init__.py. Так инициализируется это расширение:

    # ...
    from flask_login import LoginManager
    
    app = Flask(__name__)
    # ...
    login = LoginManager(app)
    
    # ...

## Подготовка User Model для Flask-Login ##

Расширение Flask-Login работает с пользовательской моделью приложения и ожидает, что в нем будут реализованы определенные свойства и методы. Такой подход хорош тем, что до тех пор, пока эти необходимые элементы добавляются в модель, Flask-Login не имеет никаких других требований, поэтому, например, он может работать с пользовательскими моделями, основанными на любой системе баз данных.

Ниже перечислены четыре обязательных элемента:

- `is_authenticated`: свойство, которое имеет значение `True`, если пользователь имеет действительные учетные данные или `False` в противном случае.
- `is_active`: свойство, которое вернет `True`, если учетная запись Пользователя активна или `False` в противном случае.
- `is_anonymous`: свойство, которое вернет `False` для обычных пользователей, и `True`, если пользователь анонимный.
- `get_id()`: метод, который возвращает уникальный идентификатор пользователя в виде строки (unicode, если используется Python 2).

Я могу легко реализовать все четыре, но поскольку реализации довольно общие, Flask-Login предоставляет *mixin* класс `UserMixin`, который включает в себя общие реализации, которые подходят для большинства классов пользовательских моделей. Вот как класс *mixin* добавляется в модель:

	# ...
	from flask_login import UserMixin
	
	class User(UserMixin, db.Model):
        # ...

## Пользовательский загрузчик ##

Flask-Login отслеживает зарегистрированного пользователя, сохраняя его уникальный идентификатор в *пользовательском сеансе* Flask, назначенный каждому пользователю, который подключается к приложению. Каждый раз, когда вошедший в систему пользователь переходит на новую страницу, Flask-Login извлекает идентификатор пользователя из сеанса и затем загружает этого пользователя в память.

Поскольку Flask-Login ничего не знает о базах данных, ему нужна помощь приложения при загрузке пользователя. По этой причине расширение ожидает, что приложение настроит функцию загрузчика пользователя, которую можно вызвать для загрузки пользователя с идентификатором. Эта функция может быть добавлена ​​в модуле *app/models.py*:

	from app import login
	# ...
	
	@login.user_loader
	def load_user(id):
	    return User.query.get(int(id))

Пользовательский загрузчик зарегистрирован в Flask-Login с помощью декоратора `@login.user_loader`. Идентификатор, который Flask-Login переходит к функции в качестве аргумента, будет строкой, поэтому для баз данных, использующих числовые идентификаторы, необходимо преобразовать строку в целое число, как вы видите выше `int(id)`.

## Вход пользователей в систему ##

Давайте перейдем к функции входа в систему, которая, как вы помните, реализовала поддельный логин, который только выдавал сообщение `flash()`. Теперь, когда приложение имеет доступ к пользовательской базе данных и знает, как создавать и проверять хэши паролей, эта функция просмотра может быть завершена ( `\microblog\app\routes.py` ).
	
	# ...
	from flask_login import current_user, login_user
	from app.models import User
	
	# ...
	
	@app.route('/login', methods=['GET', 'POST'])
	def login():
	    if current_user.is_authenticated:
	        return redirect(url_for('index'))
	    form = LoginForm()
	    if form.validate_on_submit():
	        user = User.query.filter_by(username=form.username.data).first()
	        if user is None or not user.check_password(form.password.data):
	            flash('Invalid username or password')
	            return redirect(url_for('login'))
	        login_user(user, remember=form.remember_me.data)
	        return redirect(url_for('index'))
        return render_template('login.html', title='Sign In', form=form)

Две верхние строчки в функции `login()` имеют дело со странной ситуацией. Представьте, что у вас есть пользователь, который вошел в систему и переходит к URL-адресу вашего приложения. Ясно, что это ошибка, поэтому я не хочу этого допускать. Переменная `current_user` поступает из Flask-Login и может использоваться в любое время для получения объекта пользователя. Значение этой переменной может быть пользовательским объектом из базы данных (который Flask-Login читает через обратный вызов загрузчика пользователя, представленный выше), или специальный анонимный пользовательский объект, если пользователь еще не входил в систему. Помните те свойства, которые требуются Flask в пользовательском объекте? Один из них был `is_authenticated`, что очень полезно, чтобы проверить, зарегистрирован ли пользователь или нет. Когда пользователь уже вошел в систему, я просто перенаправляю его на страницу *index*.

Вместо вызова flash(), который я использовал ранее, теперь я могу войти в систему пользователя по-настоящему. Первым шагом является загрузка пользователя из базы данных. Имя пользователя пришло с формой отправки, так что я могу запросить базу данных, чтобы найти пользователя. 

Для этого я использую метод `filter_by()` объекта запроса SQLAlchemy. Результат `filter_by()` - это запрос, который включает только объекты, у которых есть совпадающее имя пользователя. Поскольку я знаю, что будет только один или нулевой результат, я завершу запрос, вызвав `first()`, который вернет объект пользователя, если он существует, или `None`, если это не так. В **главе 4** вы видели, что когда вы вызываете метод `all()` в запросе, запрос выполняется, и вы получаете список всех результатов, соответствующих этому запросу. Метод `first()` является другим используемым способом выполнения запроса, когда вам нужен только один результат.

Если я получил соответствие для имени пользователя, которое было предоставлено, я могу проверить, действительно ли пароль, который также пришел с формой, действителен. Это делается путем вызова метода `check_password()`, определенного выше. Это приведет к хеш-паролю, хранящемуся у пользователя, и определит, соответствует ли введенный в форму пароль хешу или нет. Итак, теперь у меня есть два возможных условия ошибки: имя пользователя может быть недопустимым, или пароль может быть неправильным для пользователя. В любом из этих случаев я прокручиваю сообщение и перенаправляю обратно в приглашение для входа, чтобы пользователь мог попробовать еще раз.

Если имя пользователя и пароль верны, я вызываю функцию `login_user()`, которая поступает из Flask-Login. Эта функция будет регистрировать пользователя во время входа в систему, поэтому это означает, что на любых будущих страницах, к которым пользователь переходит, будет установлена ​​переменная `current_user` для этого пользователя.

Чтобы завершить процесс входа в систему, я просто перенаправляю вновь зарегистрированного пользователя на страницу *index*.

## Выход из системы ##

Очевидно, что нужно будет предложить пользователям возможность выхода из приложения. Это можно сделать с помощью функции `logout_user()` Flask-Login. Вот как выглядит функция выхода:
	
	# ...
	from flask_login import logout_user
	
	# ...
	
	@app.route('/logout')
	def logout():
	    logout_user()
	    return redirect(url_for('index'))

Я могу заставить ссылку «`login`» на панели навигации автоматически переключиться на ссылку «`logout`» после входа пользователя в систему. Это можно сделать с помощью условного выражения в шаблоне *base.html*:

    <div>
        Microblog:
        <a href="{{ url_for('index') }}">Home</a>
        {% if current_user.is_anonymous %}
        <a href="{{ url_for('login') }}">Login</a>
        {% else %}
        <a href="{{ url_for('logout') }}">Logout</a>
        {% endif %}
    </div>

Свойство `is_anonymous` является одним из атрибутов, которые Flask-Login добавляет к объектам пользователя через класс UserMixin. Выражение `current_user.is_anonymous` вернет `True`, только если пользователь не войдет в систему.

## Требование к пользовательскому входу ##

Flask-Login предоставляет очень полезную функцию, которая заставляет пользователей регистрироваться, прежде чем они смогут просматривать определенные страницы приложения. Если пользователь, который не выполнил вход в систему, пытается просмотреть защищенную страницу, Flask-Login автоматически перенаправляет пользователя в форму для входа и только после завершения процесса входа в систем перенаправляет на страницу, которую пользователь хотел просмотреть.

Чтобы эта функция была реализована, Flask-Login должен знать, что такое функция просмотра, которая обрабатывает логины. Это можно добавить в *app/__ init__.py:*

    # ...
    login = LoginManager(app)
    login.login_view = 'login'

Значение «login» выше является именем функции (или конечной точки) для входа в систему. Другими словами, имя, которое вы будете использовать в вызове url_for (), чтобы получить URL.

Способ Flask-Login защищает функцию просмотра от анонимных пользователей с помощью декоратора, называемого `@login_required`. Когда вы добавляете этот декоратор к функции вида под декораторами `@app.route` из Flask, функция становится защищенной и не разрешает доступ к пользователям, которые не аутентифицированы. Вот как декоратор может быть применен к функции просмотра индексов приложения:

	from flask_login import login_required
	
	@app.route('/')
	@app.route('/index')
	@login_required
	def index():
	    # ...



