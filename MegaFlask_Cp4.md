[blog.miguelgrinberg.com](http://blog.miguelgrinberg.com "blog.miguelgrinberg.com")

# Мега-Учебник Flask, Часть 4: База данных #
### *Miguel Grinberg* ###

----

Эта статья является переводом четвертой части нового издания учебника Мигеля Гринберга. [Прежний перевод](https://habrahabr.ru/post/193242/ "Прежний перевод") давно утратил свою актуальность. 

Автор планирует завершить его выпуск в мае 2018. Я, со своей стороны, постараюсь не отставать с переводом.

<cut />
Это четвертый выпуск серии Flask Mega-Tutorial, в котором я расскажу вам, как работать с базами данных.

Для справки ниже приведен список статей этой серии.

- **Глава 1: Привет, мир!**
- **Глава 2: Шаблоны**
- **Глава 3: Веб-формы**
- **Глава 4: База данных (Эта статья)**
- **Глава 5: Пользовательские логины**
- Глава 6: Страница профиля и аватары (доступно 9 января 2018 года)
- Глава 7: Обработка ошибок (доступно 16 января 2018 года)
- Глава 8: Подписчики, контакты и друзья (доступны 23 января 2018 года)
- Глава 9: Разбивка на страницы (доступна 30 января 2018 года)
- Глава 10: Поддержка электронной почты (доступна 6 февраля 2018 года)
- Глава 11: Реконструкция (доступна 13 февраля 2018 года)
- Глава 12: Дата и время (доступно 20 февраля 2018 года)
- Глава 13: I18n и L10n (доступно 27 февраля 2018 года)
- Глава 14: Ajax (доступно 6 марта 2018 года)
- Глава 15: Улучшение структуры приложения (доступно 13 марта 2018 года)
- Глава 16: Полнотекстовый поиск (доступен 20 марта 2018 года)
- Глава 17: Развертывание в Linux (доступно 27 марта 2018 года)
- Глава 18: Развертывание на Heroku (доступно 3 апреля 2018 года)
- Глава 19: Развертывание на Docker контейнерах (доступно 10 апреля 2018 года)
- Глава 20: Магия JavaScript (доступна 17 апреля 2018 года)
- Глава 21: Уведомления пользователей (доступно 24 апреля 2018 года)
- Глава 22: Справочные задания (доступны 1 мая 2018 года)
- Глава 23: Интерфейсы прикладного программирования (API) (доступно 8 мая 2018 г.)

*Примечание 1: Если вы ищете старые версии данного курса, это [здесь](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy "здесь").*

*Примечание 2: Если вдруг Вы хотели бы выступить в поддержку моей(Мигеля) работы в этом блоге, или просто не имеете терпения дожидаться неделю статьи, я (Мигель Гринберг)предлагаю полную версию данного руководства упакованную электронную книгу или видео. Для получения более подробной информации посетите [learn.miguelgrinberg.com](http://learn.miguelgrinberg.com "learn.miguelgrinberg.com").*

Тема этой главы чрезвычайно важна. Для большинства приложений необходимо поддерживать постоянные данные, которые могут быть эффективно извлечены, и это именно то, для чего создаются базы данных.

*Ссылки GitHub для этой главы:*  [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.4), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.4.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.3...v0.4).

## Базы данных в Flask ##

Поскольку я уверен, что вы уже слышали, Flask не поддерживает базы данных изначально. Это одна из многих областей, в которых Flask намеренно не самодостаточен, и это здорово, потому что у вас есть свобода выбора базы данных, которая наилучшим образом подходит для вашего приложения, вместо того, чтобы быть вынужденным адаптироваться к одному.

В Python есть большой выбор для баз данных, многие из которых интегрируются с Flask приложением. Базы данных можно разделить на две большие группы: те, которые соответствуют реляционной модели, и те, которые этого не делают. Последняя группа часто называется NoSQL, что указывает на то, что они не реализуют популярный язык реляционных запросов [SQL](https://en.wikipedia.org/wiki/SQL). Хотя в обеих группах есть отличные продукты для баз данных, я считаю, что реляционные базы данных лучше подходят для приложений, которые имеют структурированные данные, такие как списки пользователей, сообщения в блогах и т.д., В то время как базы данных NoSQL имеют тенденцию быть лучше для данных, которые имеют менее определенную структуру. Это приложение, как и большинство других, может быть реализовано с использованием любого типа базы данных, но по указанным выше причинам я собираюсь работать с реляционной базой данных.

В **главе 3** я показал вам первое расширение Flask. В этой главе я собираюсь использовать еще два. Первым является [Flask-SQLAlchemy](http://packages.python.org/Flask-SQLAlchemy), расширение, которое обеспечивает Flask-дружественную оболочку к популярному пакету [SQLAlchemy](http://www.sqlalchemy.org/), который является [Object Relational Mapper](http://en.wikipedia.org/wiki/Object-relational_mapping) или ORM. ORM позволяют приложениям управлять базой данных с использованием объектов высокого уровня, таких как классы, объекты и методы, а не таблицы и SQL. Задача ORM - перевести операции высокого уровня в команды базы данных.

Самое приятное в SQLAlchemy заключается в том, что это ORM не для одного, а для многих реляционных баз данных. SQLAlchemy поддерживает длинный список движков баз данных, включая популярные [MySQL](https://www.mysql.com/), [PostgreSQL](https://www.postgresql.org/) и [SQLite](https://www.sqlite.org/). Это очень сильно, потому что вы можете сделать свою разработку с помощью простой базы данных SQLite, которая не требует сервера, а затем, когда придет время развертывать приложение на производственном сервере, вы можете выбрать более надежный сервер MySQL или PostgreSQL, не измененяя вашего приложения.

Чтобы установить Flask-SQLAlchemy в виртуальную среду, убедитесь, что вы активировали ее сначала, а затем запустите:

    (venv) $ pip install flask-sqlalchemy

## Миграция баз данных ##

Большинство учебных пособий по базе данных, которые я видел, охватывают создание и использование базы данных, но не позволяют адекватно решить проблему создания обновлений существующей базы данных по мере того, как приложение нуждается в изменении или увеличении. Это сложно, потому что реляционные базы данных сосредоточены вокруг структурированных данных, поэтому при изменении структуры данные, которые уже находятся в базе данных, необходимо перенести в модифицированную структуру.

Второе расширение, которое я собираюсь представить в этой главе, [Flask-Migrate](https://github.com/miguelgrinberg/flask-migrate),  который фактически созданный вашим покорным слугой. Это расширение является Flask-оберткой для [Alembic](https://bitbucket.org/zzzeek/alembic), основой для миграции базы данных SQLAlchemy. Работа с миграциями баз данных добавляет немного работы вначале, но это небольшая цена, чтобы заплатить за надежный способ внесения изменений в вашу базу данных в будущем.

Процесс установки для Flask-Migrate аналогичен другим расширениям, которые вы видели:

    (venv) $ pip install flask-migrate

## Конфигурация Flask-SQLAlchemy  ##

Во время разработки я собираюсь использовать базу данных SQLite. Базы данных SQLite являются наиболее удобным выбором для разработки небольших приложений, иногда даже не очень маленьких, так как каждая база данных хранится в одном файле на диске и нет необходимости запускать сервер баз данных, как MySQL и PostgreSQL.

У нас есть два новых элемента конфигурации для добавления в файл конфигурации:

	import os
	basedir = os.path.abspath(os.path.dirname(__file__))
	
	class Config(object):
	    # ...
	    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
	        'sqlite:///' + os.path.join(basedir, 'app.db')
        SQLALCHEMY_TRACK_MODIFICATIONS = False

Расширение Flask-SQLAlchemy принимает местоположение базы данных приложения из переменной конфигурации `SQLALCHEMY_DATABASE_URI`. Как вы помните из** главы 3**, в целом рекомендуется установить конфигурацию из переменных среды и предоставить резервное значение, когда среда не определяет переменную. В этом случае я беру URL-адрес базы данных из переменной среды `DATABASE_URL`, и если это не определено, я настраиваю базу данных с именем *app.db*, расположенную в основном каталоге приложения, которая хранится в переменной `basedir`.

Параметр конфигурации `SQLALCHEMY_TRACK_MODIFICATIONS` установлен в значение False, чтобы отключить функцию Flask-SQLAlchemy, которая мне не нужна, которая должна сигнализировать приложению каждый раз, когда в базе данных должно быть внесено изменение.

База данных будет представлена ​​в приложении, как *database instance*. Механизм миграции базы данных также будет иметь экземпляр. Это объекты, которые необходимо создать после приложения, в файле `app/__ init__.py`:

	from flask import Flask
	from config import Config
	from flask_sqlalchemy import SQLAlchemy
	from flask_migrate import Migrate
	
	app = Flask(__name__)
	app.config.from_object(Config)
	db = SQLAlchemy(app)
	migrate = Migrate(app, db)
	
    from app import routes, models

Я внес три изменения в скрипт init. Во-первых, я добавил объект `db`, который представляет базу данных. Затем я добавил еще один объект, который представляет механизм миграции. Надеюсь, вы увидите образец работы с расширениями Flask. Большинство расширений инициализируются как эти два. Наконец, я импортирую новый модуль под названием `models`  внизу. Этот модуль определит структуру базы данных.

## Модели баз данных ##

Данные, которые будут храниться в базе данных, будут представлены набором классов, обычно называемых моделями баз данных. Уровень ORM в SQLAlchemy будет выполнять переводы, необходимые для сопоставления объектов, созданных из этих классов, в строки в соответствующих таблицах базы данных.

Начнем с создания модели, представляющей пользователей. Используя инструмент [WWW SQL Designer](http://ondras.zarovi.cz/sql/demo), я сделал следующую диаграмму для представления данных, которые мы хотим использовать в таблице users:

[![](https://blog.miguelgrinberg.com/static/images/mega-tutorial/ch04-users.png)](http://ondras.zarovi.cz/sql/demo)

Поле `id` обычно используется во всех моделях и используется как первичный ключ. Каждому пользователю в базе данных будет присвоено уникальное значение идентификатора, сохраненное в этом поле. Первичные ключи в большинстве случаев автоматически назначаются базой данных, поэтому мне просто нужно указать поле `id`, помеченное как первичный ключ.

Поля `username`,  `email` и `password_hash` определяются как строки (или `VARCHAR` на жаргоне базы данных), а их максимальная длина указывается так, чтобы база данных могла оптимизировать использование пространства. Хотя поля `username`  и `email` не требуют пояснений, поля `password_hash` заслуживают внимания. Я хочу убедиться, что приложение, которое я создаю, использует лучшие рекомендации по безопасности, и по этой причине я не буду хранить пароли пользователей в базе данных. Проблема с хранением паролей заключается в том, что если база данных когда-либо становится скомпрометированной, злоумышленники будут иметь доступ к паролям, и это может быть разрушительным для пользователей. Вместо того, чтобы писать пароли напрямую, я собираюсь написать *хэши паролей* (password hashes), которые значительно улучшают безопасность. Это будет тема другой главы, так что не беспокойтесь об этом сейчас.

Итак, теперь, когда я знаю, что мне нужно для таблицы моих пользователей, я могу перевести это в код в новом модуле *app/models.py*:

	from app import db
	
	class User(db.Model):
	    id = db.Column(db.Integer, primary_key=True)
	    username = db.Column(db.String(64), index=True, unique=True)
	    email = db.Column(db.String(120), index=True, unique=True)
	    password_hash = db.Column(db.String(128))
	
	    def __repr__(self):
        return '<User {}>'.format(self.username) 

Созданный выше класс `User` наследует от `db.Model`, базового класса для всех моделей из Flask-SQLAlchemy. Этот класс определяет несколько полей как переменные класса. Поля создаются как экземпляры класса `db.Column`, который принимает тип поля в качестве аргумента, плюс другие необязательные аргументы, которые, например, позволяют мне указать, какие поля уникальны и индексированы, что важно для эффективного поиска базы данных ,

Метод `__repr__` сообщает Python, как печатать объекты этого класса, что будет полезно для отладки. Вы можете увидеть метод `__repr __()` в действии в сеансе интерпретатора Python ниже:   

    >>> from app.models import User
    >>> u = User(username='susan', email='susan@example.com')
    >>> u
    <User susan>

## Создание миграции репозитория ## 

Класс модели, созданный в предыдущем разделе, определяет исходную структуру (или *схему*) базы данных для этого приложения. Но по мере того, как приложение продолжает расти, потребуется изменить структуру, которая, скорее всего, добавит новые сущности, но иногда также может изменять или удалять элементы. Alembic (инфраструктура миграции, используемая Flask-Migrate) сделает эти изменения схемы таким образом, чтобы не требовалось воссоздавать базу данных с нуля.

Чтобы выполнить эту, казалось бы, сложную задачу, Alembic поддерживает репозиторий *миграции*, который является каталогом, в котором хранится его сценарии миграции. Каждый раз, когда в схему базы данных вносится изменение, в репозиторий добавляется сценарий миграции с подробными сведениями об изменении. Чтобы применить миграции к базе данных, эти сценарии миграции выполняются в той последовательности, в которой они были созданы.

Flask-Migrate выдает свои команды через `flask` команду. Вы уже видели `flask run`, который является подчиненной командой, которая является родной для Flask. Подкоманда `flask db` добавляется Flask-Migrate для управления всем, что связано с миграцией базы данных. Итак, давайте создадим репозиторий миграции для microblog, запустив`flask db init`:

	(venv) $ flask db init
	  Creating directory /home/miguel/microblog/migrations ... done
	  Creating directory /home/miguel/microblog/migrations/versions ... done
	  Generating /home/miguel/microblog/migrations/alembic.ini ... done
	  Generating /home/miguel/microblog/migrations/env.py ... done
	  Generating /home/miguel/microblog/migrations/README ... done
	  Generating /home/miguel/microblog/migrations/script.py.mako ... done
	  Please edit configuration/connection/logging settings in
      '/home/miguel/microblog/migrations/alembic.ini' before proceeding.

Помните, что `flask` команда полагается на переменную среды `FLASK_APP`, чтобы знать, где расположено приложение Flask. Для этого приложения вы хотите установить `FLASK_APP=microblog.py`, как описано в **главе 1**.

После запуска этой команды вы найдете новый каталог *migrations* , в котором есть несколько файлов и подкаталог *версий*. Все эти файлы теперь должны рассматриваться как часть вашего проекта и, их необходимо добавить в систему управления версиями.

## Первая миграция базы данных ##

При наличии репозитория миграции настало время создать первую миграцию базы данных, которая будет включать таблицу `Users`, сопоставляемую с моделью пользовательской базы данных. Существует два способа создания миграции базы данных: вручную или автоматически. Для автоматического создания миграции Alembic сравнивает схему базы данных, определенную моделями баз данных, с фактической схемой базы данных, используемой в настоящее время в базе данных. Затем он заполняет сценарий переноса изменениями, необходимыми для того, чтобы схема базы данных соответствовала моделям приложений. В этом случае, поскольку нет предыдущей базы данных, автоматический перенос добавит всю `User`  модель в сценарий переноса. `flask db migrate` Подкоманда переноса DB генерирует эти автоматические миграции:

	(venv) $ flask db migrate -m "users table"
	INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
	INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
	INFO  [alembic.autogenerate.compare] Detected added table 'user'
	INFO  [alembic.autogenerate.compare] Detected added index 'ix_user_email' on '['email']'
	INFO  [alembic.autogenerate.compare] Detected added index 'ix_user_username' on '['username']'
    Generating /home/miguel/microblog/migrations/versions/e517276bb1c2_users_table.py ... done

Вывод команды дает вам представление о том, что Alembic включен в миграцию. Первые две строки являются информационными и их обычно можно игнорировать. Затем он говорит, что нашел таблицу `'user'` и два индекса `'['email']'` и '['username']'. Затем он сообщает вам, где он написал сценарий миграции. Код e517276bb1c2 - это автоматически созданный уникальный код для миграции (он будет другим для вас). Комментарий, заданный с параметром `-m`, является необязательным, он добавляет короткий описательный текст в перенос.

Сгенерированный сценарий миграции теперь является частью вашего проекта и должен быть включен в систему управления версиями. Вы можете просмотреть сценарий, если вам интересно посмотреть, как он выглядит. Вы обнаружите, что у него есть две функции: `upgrade()` и `downgrade()`. Функция `upgrade()` применяет миграцию, а функция `downgrade()` удаляет ее. Это позволяет Alembic переносить базу данных в любую точку истории, даже в более старые версии, используя путь понижения.

Команда `flask db migrate` не вносит никаких изменений в базу данных, она просто создает сценарий миграции. Чтобы применить изменения в базе данных, необходимо использовать команду `flask db upgrade`.

	(venv) $ flask db upgrade
	INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
	INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    INFO  [alembic.runtime.migration] Running upgrade  -> e517276bb1c2, users table

