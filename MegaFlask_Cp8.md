[blog.miguelgrinberg.com](http://blog.miguelgrinberg.com "blog.miguelgrinberg.com")


### *Miguel Grinberg* ###

----

[<<< предыдущая](https://habrahabr.ru/post/346348/)  [следующая >>>](https://habrahabr.ru/post/346348/)

Эта статья является переводом восьмой части нового издания учебника Мигеля Гринберга, выпуск которого автор планирует завершить в мае 2018.[Прежний перевод](https://habrahabr.ru/post/193242/ "Прежний перевод") давно утратил свою актуальность. 

----------

Это восьмая часть серии Flask Mega-Tutorial, в которой я расскажу вам, как реализовать функцию «подписчики», аналогичную функции Twitter и других социальных сетей.
<cut />
Для справки ниже приведен список статей этой серии.


<spoiler title="Оглавление">

- [**Глава 1: Привет, мир!**](https://habrahabr.ru/post/346306/)
- [**Глава 2: Шаблоны**](https://habrahabr.ru/post/346340/)
- [**Глава 3: Веб-формы**](https://habrahabr.ru/post/346342/)
- [**Глава 4: База данных **](https://habrahabr.ru/post/346344/)
- [**Глава 5: Пользовательские логины**](https://habrahabr.ru/post/346346/)
- [**Глава 6: Страница профиля и аватары**](https://habrahabr.ru/post/346348/)
- [**Глава 7: Обработка ошибок (Эта статья)**](https://habrahabr.ru/post/346880/)
- Глава 8: Подписчики, контакты и друзья (доступны 23 января 2018 года)
- Глава 9: Разбивка на страницы (доступна 30 января 2018 года)
- Глава 10: Поддержка электронной почты (доступна 6 февраля 2018 года)
- Глава 11: Реконструкция (доступна 13 февраля 2018 года)
- Глава 12: Дата и время (доступно 20 февраля 2018 года)
- Глава 13: I18n и L10n (доступно 27 февраля 2018 года)
- Глава 14: Ajax (доступно 6 марта 2018 года)
- Глава 15: Улучшение структуры приложения (доступно 13 марта 2018 года)
- Глава 16: Полнотекстовый поиск (доступен 20 марта 2018 года)
- Глава 17: Развертывание в Linux (доступно 27 марта 2018 года)
- Глава 18: Развертывание на Heroku (доступно 3 апреля 2018 года)
- Глава 19: Развертывание на Docker контейнерах (доступно 10 апреля 2018 года)
- Глава 20: Магия JavaScript (доступна 17 апреля 2018 года)
- Глава 21: Уведомления пользователей (доступно 24 апреля 2018 года)
- Глава 22: Справочные задания (доступны 1 мая 2018 года)
- Глава 23: Интерфейсы прикладного программирования (API) (доступно 8 мая 2018 г.)

</spoiler>
*Примечание 1: Если вы ищете старые версии данного курса, это [здесь](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy "здесь").*

*Примечание 2: Если вдруг Вы хотели бы выступить в поддержку моей(Мигеля) работы в этом блоге, или просто не имеете терпения дожидаться неделю статьи, я (Мигель Гринберг)предлагаю полную версию данного руководства упакованную электронную книгу или видео. Для получения более подробной информации посетите [learn.miguelgrinberg.com](http://learn.miguelgrinberg.com "learn.miguelgrinberg.com").*

В этой главе я еще немного поработаю над структурой базы данных. Я хочу, чтобы пользователи приложения могли легко организовать подписку на интересующий их контент. Поэтому я собираюсь внести изменения в базу данных, чтобы она могла следить за тем, кто следит за кем, это несколько сложнее, чем вы думаете.

*Ссылки GitHub для этой главы:*  [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.8), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.8.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.7...v0.8).

## Снова связи базы данных ##
Как я сказал выше, хочу поддерживать список пользователей «отслеживаемых» и «подписчиков» *( "followed" and "follower" )* для каждого пользователя. К сожалению, реляционная база данных не имеет типа `list` список, который я могу использовать для этих самых списков, все, что есть -- это таблицы с записями и отношениями между этими записями.

В базе данных есть таблица, представляющая пользователей `users`, так что осталось придумать правильный тип отношений, который может моделировать *followed/follower * ссылку. Давайте просмотрим базовые типы отношений в базе данных:

### Один ко многим ( One-to-Many )###
Я уже использовал отношения *«один ко многим»* в **главе 4**. Вот диаграмма для этой связи:

![](https://habrastorage.org/webt/sr/2u/1c/sr2u1cy4uzvxvxn5nyairks7qns.png)

Двумя объектами, связанными этим отношением, являются пользователи и сообщения. Видим, что у пользователя *много* сообщений, а у сообщения есть *один* пользователь (или автор). Связь представлена ​​в базе данных с использованием внешнего ключа *foreign key* на стороне «много». В вышеприведенной связи внешний ключ - это поле `user_id`, добавленное в таблицу сообщений `posts` .
Это поле связывает каждое сообщение с записью его автора в пользовательской таблице.

Очевидно, что поле `user_id` обеспечивает прямой доступ к автору данного сообщения, но как насчет обратного направления? Чтобы связь была полезной, я должен иметь возможность получить список сообщений, написанных данным пользователем.
Поле `user_id` в таблице `posts` также является достаточным для ответа на этот вопрос, поскольку базы данных имеют индексы, которые позволяют создавать эффективные запросы, так что мы «извлекаем ( retrieve  ) все сообщения, которые имеют user_id из X».

### Многие-ко-многим ( Many-to-Many ) ###
Отношение «многие ко многим» несколько сложнее. В качестве примера рассмотрим базу данных, в которой есть студенты `students` и преподаватели `teachers`. Могу сказать, что у студента много учителей, а у учителя много учеников. Это похоже на два взаимосвязанных отношения «один ко многим» с обоих концов.
Для отношений этого типа я должен быть в состоянии запросить базу данных и получить список учителей, которые учат данного учащегося, и список учеников в классе учителя. Это нетривиально для представления в реляционной базе данных, поскольку это невозможно сделать, добавив внешние ключи к существующим таблицам.

Представление многозначного представления, `many-to-many` требуют использования вспомогательной таблицы, называемой таблицей ассоциаций *association table*. Вот пример  организации поиска студентов и преподавателей в базе:

![](https://habrastorage.org/webt/5a/s8/0v/5as80vr1zyjj5lsm3ckpubokbpo.png)

Возможно кому то это может показаться неясным, таблица ассоциаций с двумя внешними ключами эффективно отвечает на все запросы о взаимоотношениях.

### «Много-к-одному» и «один-к-одному» ( Many-to-One and One-to-One ) ###
Много-к-одному похоже на отношение один-ко-многим. Разница в том, что эта связь рассматривается со стороны «Много».

Один-к-одному - частный случай «один ко многим». Представление аналогично, но в базу данных добавляется ограничение, чтобы предотвратить сторону «Много»,   запрещающее иметь более одной ссылки.
Хотя бывают случаи, когда этот тип отношений полезен, но он не так распространен, как другие типы.

## Представление подписчиков ##
По сумме анализа всех представленных выше типов отношений, легко определить, что правильная модель данных для отслеживания подписчиков *followers*  - это отношения «многие ко многим», поскольку отслеживаемый (follows) следит за *многими* пользователями (users), а пользователь (user)  имеет *много* подписчиков (followers). Но тут есть подстава. В примере с учениками и учителями у меня было два объекта, которые были связаны между собой отношениями «многие ко многим». Но в случае с подписчиками (followers) у меня есть пользователи, которые следуют за другими пользователями, поэтому есть только пользователи. Итак, какова вторая структура отношений «многие-ко-многим»?

Второй объект отношений - это также пользователи.
Отношение, в котором экземпляры класса связаны с другими экземплярами одного и того же класса, называется самореферентным отношением ( self-referential relationship ), и именно это я здесь и имею.

Вот диаграмма самореферентных отношений «многие ко многим» отслеживания подписчиков:

![](https://habrastorage.org/webt/rm/7y/9v/rm7y9viomscnk0u2uq1nwbscjra.png)

Таблица `followers`  - это таблица ассоциаций отношений или таблицей относительных связей. Внешние ключи ( foreign keys ) в этой таблице указывают на записи в пользовательской таблице, поскольку они связывают пользователей с пользователями. Каждая запись в этой таблице представляет собой одну связь между пользователем-подписчиком follower user и подписанным пользователем followed user. Как пример учеников и учителей, такая настройка, как эта, позволяет базе данных отвечать на все вопросы о подписанных и подписчиках, которые мне когда-либо понадобятся. Довольно аккуратно.

## Представление модели базы данных ##
Давайте сначала добавим последователей в базу данных. Вот таблица ассоциаций подписчиков:

    followers = db.Table('followers',
	    db.Column('follower_id', db.Integer, db.ForeignKey('user.id')),
	    db.Column('followed_id', db.Integer, db.ForeignKey('user.id'))
    )

Это прямая трансляция таблицы ассоциаций из моей диаграммы выше. Обратите внимание, что я не объявляю эту таблицу в качестве модели, как я сделал для таблиц пользователей и сообщений. Поскольку это вспомогательная таблица, которая не имеет данных, отличных от внешних ключей, я создал ее без соответствующего класса модели.

Теперь я могу объявить отношения «многие ко многим» в таблице users:

	class User(UserMixin, db.Model):
	    # ...
	    followed = db.relationship(
	        'User', secondary=followers,
	        primaryjoin=(followers.c.follower_id == id),
	        secondaryjoin=(followers.c.followed_id == id),
	        backref=db.backref('followers', lazy='dynamic'), lazy='dynamic')

Настройка отношения нетривиальна. Как и в случае отношений `posts` «один-ко-многим», я использую функцию `db.relationship` для определения отношений в классе модели. Эта взаимосвязь связывает экземпляры `User` с другими экземплярами `User`, так как соглашение позволяет сказать, что для пары пользователей, связанных этим отношением, пользователь левой стороны следит за пользователем правой стороны. Я определяю связь, как видно из левой стороны с именем `followed`, потому что, когда я запрашиваю эту связь с левой стороны, я получу список последующих пользователей (т.e. тех, на правой стороне). Давайте рассмотрим все аргументы вызова `db.relationship()` один за другим:


- `'User'` - это правая сторона связи (левая сторона - это родительский класс). Поскольку это самореферентное отношение, я должен использовать тот же класс с обеих сторон.
- `secondary` кофигурирует таблицу ассоциаций, которая используется для этой связи, которую я определил прямо над этим классом.
- `primaryjoin` указывает условие, которое связывает объект левой стороны (follower user) с таблицей ассоциаций. Условием объединения для левой стороны связи является идентификатор пользователя, соответствующий полю `follower_id` таблицы ассоциаций. Выражение `followers.c.follower_id` ссылается на столбец `follower_id` таблицы ассоциаций.
- `secondaryjoin` определяет условие, которое связывает объект правой стороны (followed user) с таблицей ассоциаций. Это условие похоже на `primaryjoin`, с той лишь разницей, что теперь я использую `follow_id`, который является другим внешним ключом в таблице ассоциаций.
- `backref` определяет, как эта связь будет доступна из правой части объекта. С левой стороны отношения пользователи называются `followed`, поэтому с правой стороны я буду использовать имя `followers` , чтобы представить всех пользователей левой стороны, которые связаны с целевым пользователем в правой части. Дополнительный `lazy`  аргумент указывает режим выполнения этого запроса. Режим `dynamic` настройки запроса не позволяет запускаться до тех пор, пока не будет выполнен конкретный запрос, что также связано с тем, как установлено отношения «один ко многим».
-`lazy` похож на параметр с тем же именем в `backref`, но этот относится к левой, а не к правой стороне.

Не беспокойтесь, если это трудно понять. Я покажу вам, как работать с этими запросами и тогда в одно мгновение все станет понятнее.

Изменения в базе данных необходимо записать в новой миграции базы данных:
	
	(venv) $ flask db migrate -m "followers"
	INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
	INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
	INFO  [alembic.autogenerate.compare] Detected added table 'followers'
	  Generating /home/miguel/microblog/migrations/versions/ae346256b650_followers.py ... done
	
	(venv) $ flask db upgrade
	INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
	INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
	INFO  [alembic.runtime.migration] Running upgrade 37f06a334dbf -> ae346256b650, followers

## Добавление и удаление "follows" (подписчика) ##
Благодаря ORM SQLAlchemy пользователь, подписывающийся на отслеживание другого пользователя, может быть записан в базу данных, как `followed`  если бы это был список. Например, если у меня было два пользователя, которые хранятся в переменных `user1` и `user2`, я могу сделать первого `user1` следящим за вторым `user2` с помощью этого простого оператора:

    user1.followed.append(user2)

Чтобы `user1` отказаться от слежения за пользователем `user2`, надо сделать так:

    user1.followed.remove(user2)

Несмотря на то, что добавление и удаление подписчиков делается довольно легко, я хочу упростить повторное использование в своем коде, поэтому я не собираюсь "добавлять" (appends) и "удалять" (removes) через код. Вместо этого я собираюсь реализовать функциональность "follow" и "unfollow" как методы в `User` модели. Всегда лучше переместить логику приложения подальше от функций просмотра в модель или в другие вспомогательные классы или модули, потому что, как вы увидите далее в этой главе, это делает модульное тестирование намного проще.

Ниже приведены изменения в пользовательской модели для добавления и удаления связей:
	
	class User(UserMixin, db.Model):
	    #...
	
	    def follow(self, user):
	        if not self.is_following(user):
	            self.followed.append(user)
	
	    def unfollow(self, user):
	        if self.is_following(user):
	            self.followed.remove(user)
	
	    def is_following(self, user):
	        return self.followed.filter(
	            followers.c.followed_id == user.id).count() > 0
	
Методы `follow()` и `unfollow()` используют методы `append()` и `remove()` объекта, как показано выше, но прежде чем они будут применены, они используют метод проверки `is_following()`, чтобы убедиться, что запрошенное действие обладает смыслом. Например, если я попрошу *user1* следить за *user2*, но оказывается, что такая задача уже существует в базе данных, то зачем создавать дубликат. Та же логика может быть применена к `unfollowing`.

Метод `is_following()` формирует запрос на проверку отношения, существует ли связь между двумя пользователями. Раньше я  уже использовал метод `filter_by()` запроса SQLAlchemy, например, чтобы найти пользователя по его *username*. Метод `filter()`, который я использую здесь, аналогичен, но является более низкоуровневым, поскольку он может включать произвольные условия фильтрации, в отличие от `filter_by()`, который может только проверять равенство на постоянное значение. Условие, которое я использую в `is_following()`, ищет элементы в таблице ассоциаций, которые имеют внешний ключ левой стороны, установленный для  `self` пользователя, а правая сторона - для аргумента `user` . Запрос завершается методом `count()`, который возвращает количество записей. Результатом этого запроса будет `0` или `1`, поэтому проверка того, что счетчик равен 1 или больше 0, фактически эквивалентен. Другие терминаторы запросов, которые вы видели в прошлом, - это `all()` и `first()`.


## Получение сообщений от Followed Users ##
Поддержка подписчиков в базе данных почти завершена, но на самом деле у меня отсутствует одна важная функция. На странице *index*  приложения я собираюсь показать записи в блогах, написанные всеми людьми, за которыми следит зарегистрированный пользователь, поэтому мне нужно сформировать запрос базы данных, который вернет эти сообщения.

Наиболее очевидным решением является запуск запроса, который вернет список followed пользователей, который, как вы уже знаете, будет `user.followed.all()`. Затем для каждого из этих пользователей я могу запустить запрос для получения их сообщений. Когда у меня будут все сообщения, я могу объединить их в один список и отсортировать их по дате. Звучит хорошо? Ну не совсем.

У этого подхода есть несколько проблем. Что произойдет, если подписка пользователя будет насчитывать тысячи людей? Мне нужно выполнить тысячи запросов базы данных, чтобы собрать все сообщения. И тогда мне нужно будет объединить и отсортировать тысячи списков в памяти. В качестве вторичной проблемы учесть, что домашняя страница приложения в конечном итоге будет выполняться с *разбивкой* по страницам, поэтому она не отобразит все доступные сообщения, а только первые несколько, со ссылкой, чтобы получить больше, если потребуется. Если я собираюсь отображать сообщения, отсортированные по их дате, как я могу узнать, какие сообщения являются последними из всех отслеживаемых (followed) пользователей, если только я не получу все сообщения и не сортирую их в первую очередь? Это действительно жуткое решение, которое плохо масштабируется.

Нет никакого способа избежать этого объединения и сортировки сообщений в блогах, но выполнение этого в приложении приводит к очень неэффективному процессу. Такая работа - это то, чем отличаются реляционные базы данных. База данных имеет индексы, которые позволяют ей выполнять запросы и сортировку гораздо более эффективным способом. Так что я действительно хочу создать единый запрос базы данных, который определяет информацию, которую я хочу получить, а затем дать базе данных понять, как извлечь эту информацию наиболее эффективным способом.

Ниже вы можете увидеть этот запрос: