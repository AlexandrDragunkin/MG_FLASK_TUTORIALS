[blog.miguelgrinberg.com](http://blog.miguelgrinberg.com "blog.miguelgrinberg.com")

# Мега-Учебник Flask, Часть 2: Шаблоны #
### *Miguel Grinberg* ###

----

Эта статья является переводом второй части нового издания учебника Мигеля Гринберга. [Прежний перевод](https://habrahabr.ru/post/193242/ "Прежний перевод") давно утратил свою актуальность. Оригинальный учебник избавлен от некоторых неточностей, вызванных быстрым развитием веб, но лучше пользоваться новым.

Автор планирует завершить его выпуск в мае 2018. Я, со своей стороны, постараюсь не отставать с переводом.


В этом втором выпуске серии Мега-Учебник Flask я расскажу о том, как работать с шаблонами.

Для справки ниже приведен список статей этой серии.

- **Глава 1: Привет, мир! (Эта статья)**
- **Глава 2: Шаблоны**
- **Глава 3: Веб-формы**
- **Глава 4: База данных**
- **Глава 5: Пользовательские логины**
- Глава 6: Страница профиля и аватары (доступно 9 января 2018 года)
- Глава 7: Обработка ошибок (доступно 16 января 2018 года)
- Глава 8: Подписчики, контакты и друзья (доступны 23 января 2018 года)
- Глава 9: Разбивка на страницы (доступна 30 января 2018 года)
- Глава 10: Поддержка электронной почты (доступна 6 февраля 2018 года)
- Глава 11: Реконструкция (доступна 13 февраля 2018 года)
- Глава 12: Дата и время (доступно 20 февраля 2018 года)
- Глава 13: I18n и L10n (доступно 27 февраля 2018 года)
- Глава 14: Ajax (доступно 6 марта 2018 года)
- Глава 15: Улучшение структуры приложения (доступно 13 марта 2018 года)
- Глава 16: Полнотекстовый поиск (доступен 20 марта 2018 года)
- Глава 17: Развертывание в Linux (доступно 27 марта 2018 года)
- Глава 18: Развертывание на Heroku (доступно 3 апреля 2018 года)
- Глава 19: Развертывание на Docker контейнерах (доступно 10 апреля 2018 года)
- Глава 20: Магия JavaScript (доступна 17 апреля 2018 года)
- Глава 21: Уведомления пользователей (доступно 24 апреля 2018 года)
- Глава 22: Справочные задания (доступны 1 мая 2018 года)
- Глава 23: Интерфейсы прикладного программирования (API) (доступно 8 мая 2018 г.)

*Примечание 1: Если вы ищете старые версии данного курса, это [здесь](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy "здесь").*

*Примечание 2: Если вдруг Вы хотели бы выступить в поддержку моей(Мигеля) работы в этом блоге, или просто не имеете терпения дожидаться неделю статьи, я (Мигель Гринберг)предлагаю полную версию данного руководства упакованную электронную книгу или видео. Для получения более подробной информации посетите [learn.miguelgrinberg.com](http://learn.miguelgrinberg.com "learn.miguelgrinberg.com").*

После завершения **главы 1** вы должны иметь полностью работающее, но простое веб-приложение, имеющее следующую структуру файлов:
    
	microblog\
	  venv\
	  app\
	    __init__.py
	    routes.py
	  microblog.py
    
Для запуска приложения вы устанавливаете `FLASK_APP=microblog.py` в сеансе терминала, а затем выполняете запуск flask. Это запустит веб-сервер с приложением, которое вы можете открыть, введя `http://localhost:5000` / URL в адресной строке вашего веб-браузера.

В этой главе вы продолжите работу над одним и тем же приложением, и, в частности, вы узнаете, как создавать более сложные веб-страницы, которые имеют сложную структуру и множество динамических компонентов. Если что-либо о приложении или технологическом процессе разработки пока неясно, перед продолжением просмотрите **главу 1**.

*Ссылки GitHub для этой главы:*  [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.2), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.2.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.1...v0.2).

## Что такое шаблоны? ##

Я хочу, чтобы на домашней странице моего приложения для микроблогов был заголовок, приветствующий пользователя. На данный момент я проигнорирую тот факт, что приложение еще не имеет концепции пользователей, поскольку это произойдет позже. Вместо этого я собираюсь использовать вымышленного (mock) пользователя, которого я собираюсь реализовать как словарь Python, следующим образом:

    user = {'username': 'Miguel'}

Создание mock-объектов - полезный метод, который позволяет вам сосредоточиться на одной части приложения, не беспокоясь о других частях системы, которые еще не существуют. Я хочу создать домашнюю страницу своего приложения, и я не хочу, чтобы у меня не было системы пользователя, чтобы отвлечь меня, поэтому я просто создаю объект пользователя.

Функция просмотра в приложении возвращает простую строку. Теперь я хочу расширить эту возвращаемую строку в полную HTML-страницу, возможно, что-то вроде этого:


	from app import app
	
	@app.route('/')
	@app.route('/index')
	def index():
	    user = {'username': 'miguel'}
	    return '''
	<html>
	    <head>
	        <title>Home Page - Microblog</title>
	    </head>
	    <body>
	        <h1>Hello, ''' + user['username'] + '''!</h1>
	    </body>
	</html>'''

Если Вы не знакомы с HTML, я рекомендую, чтобы Вы прочитали [Markup HTML](https://en.wikipedia.org/wiki/HTML#Markup) в Википедии для краткого введения.

Обновите функцию представления как показано выше и смотрите в Вашем браузере.

![](https://blog.miguelgrinberg.com/static/images/mega-tutorial/ch02-mock-user.png)

Я надеюсь, Вы согласитесь со мной, что решение, используемое выше, не достаточно хорошо. Подумайте, насколько сложным будет код в этой функции просмотра, когда у меня появятся сообщения в блоге от пользователей, которые будут постоянно меняться. Приложение также будет иметь больше функций просмотра, которые будут связаны с другими URL-адресами, поэтому представьте, если в один прекрасный день я решу изменить макет этого приложения и вам придется обновлять HTML в каждой функции просмотра. Это явно не вариант, который будет масштабироваться по мере роста приложения.

Если бы вы могли сохранить логику своего приложения отдельно от макета или презентации ваших веб-страниц, тогда было бы намного лучше организовано, не так ли? Вы даже можете нанять веб-дизайнера для создания убойного сайта, когда вы закодируете логику приложения в Python.

Шаблоны помогают достичь этого разделения между презентацией и бизнес-логикой. В Flask шаблоны записываются как отдельные файлы, хранящиеся в папке `templates`, которая находится внутри пакета приложения. Поэтому, убедившись, что вы находитесь в каталоге `microblog`, создайте каталог, в котором будут храниться шаблоны:

    (venv) $ mkdir app/templates

Ниже вы можете увидеть свой первый шаблон, который похож по функциональности на страницу HTML, возвращаемую функцией просмотра `index()` выше. Запишите этот файл в `app/templates/index.html`:

	<html>
	    <head>
	        <title>{{ title }} - Microblog</title>
	    </head>
	    <body>
	        <h1>Hello, {{ user.username }}!</h1>
	    </body>
	</html>

Это стандартная, очень простая HTML-страница. Единственная интересная вещь на этой странице состоит в том, что для динамического контента есть несколько заполнителей, заключенных в `{{...}}` разделы. Эти заполнители представляют части страницы, которые являются переменными и будут определены только во время выполнения.

Теперь, когда презентация страницы была выгружена в шаблон HTML, функция просмотра может быть упрощена:

	from flask import render_template
	from app import app
	
	@app.route('/')
	@app.route('/index')
	def index():
	    user = {'username': 'Miguel'}
	    return render_template('index.html', title='Home', user=user)

Это выглядит намного лучше, не так ли? Попробуйте эту новую версию приложения, чтобы посмотреть, как работает шаблон. Как только вы загрузите страницу в свой браузер, вы можете просмотреть исходный HTML-код и сравнить его с исходным шаблоном.

Операция, которая преобразует шаблон в полную HTML-страницу, называется рендерингом. Чтобы отобразить шаблон, мне пришлось импортировать функцию, которая поставляется с флаговой инфраструктурой под названием `render_template()`. Эта функция принимает имя файла шаблона и переменную список аргументов шаблона и возвращает один и тот же шаблон, но при этом все заполнители в нем заменяются фактическими значениями.

Функция `render_template()` вызывает механизм шаблонов `Jinja2`, который поставляется в комплекте с Flask. `Jinja2` заменяет блоки `{{...}}` соответствующими значениями, заданными аргументами, указанными в вызове `render_template()`.

## Условные операторы ##

Вы видели, как `Jinja2` заменяет заполнители фактическими значениями во время рендеринга, но это всего лишь одна из многих мощных операций, поддерживаемых `Jinja2` в файлах шаблонов. Например, шаблоны также поддерживают управляющие операторы, заданные внутри блоков `{% ...%}`. Следующая версия шаблона `index.html` добавляет условное выражение:

	<html>
	    <head>
	        {% if title %}
	        <title>{{ title }} - Microblog</title>
	        {% else %}
	        <title>Welcome to Microblog!</title>
	        {% endif %}
	    </head>
	    <body>
	        <h1>Hello, {{ user.username }}!</h1>
	    </body>
	</html>

Теперь шаблон немного умнее. Если функция просмотра забывает передать значение переменной заполнитель заголовка, вместо того, чтобы показывать пустой заголовок, шаблон предоставит значение по умолчанию. Вы можете попробовать, как это условие работает, удалив аргумент *title* в вызове `render_template()` функции view.

## Циклы ##

Пользователь, вошедший в систему, вероятно, захочет увидеть последние сообщения от подключенных пользователей на домашней странице, поэтому теперь я собираюсь расширить приложение, для поддержки этого.

Еще раз, использую трюк с поддельным объектом, чтобы создать некоторых пользователей и некоторые сообщения, для демонстрации:

	from flask import render_template
	from app import app
	
	@app.route('/')
	@app.route('/index')
	def index():
	    user = {'username': 'Miguel'}
	    posts = [
	        {
	            'author': {'username': 'John'},
	            'body': 'Beautiful day in Portland!'
	        },
	        {
	            'author': {'username': 'Susan'},
	            'body': 'The Avengers movie was so cool!'
	        }
	    ]
	    return render_template('index.html', title='Home', user=user, posts=posts)

Для представления пользовательских сообщений я использую список, где каждый элемент является словарем, имеющим поля `Author` и `Body`. Когда я доберусь до реализации пользователей и сообщений в блоге по-настоящему, я постараюсь сохранить эти имена полей как можно больше, чтобы вся работа, которую я делаю для проектирования и тестирования шаблона домашней страницы, используя эти поддельные объекты, продолжала действовать, когда я представляю реальных пользователей и сообщения.


На стороне шаблона я должен решить новую проблему. Список сообщений может иметь любое количество элементов, это до функции просмотра, чтобы решить, сколько Сообщений будут представлены на странице. Шаблон не может делать какие-либо предположения о том, сколько записей существует, поэтому он должен быть готов к отображению столько Сообщений, сколько отправляет представление общим способом.

Для этого типа проблемы, Jinja2 предлагает a для структуры управления:

	<html>
	    <head>
	        {% if title %}
	        <title>{{ title }} - Microblog</title>
	        {% else %}
	        <title>Welcome to Microblog</title>
	        {% endif %}
	    </head>
	    <body>
	        <h1>Hi, {{ user.username }}!</h1>
	        {% for post in posts %}
	        <div><p>{{ post.author.username }} says: <b>{{ post.body }}</b></p></div>
	        {% endfor %}
	    </body>
	</html>
