[blog.miguelgrinberg.com](http://blog.miguelgrinberg.com "blog.miguelgrinberg.com")


### *Miguel Grinberg* ###

----

[<<< предыдущая](https://habrahabr.ru/post/346348/)  [следующая >>>](https://habrahabr.ru/post/346348/)

Эта статья является переводом седьмой части нового издания учебника Мигеля Гринберга, выпуск которого автор планирует завершить в мае 2018.[Прежний перевод](https://habrahabr.ru/post/193242/ "Прежний перевод") давно утратил свою актуальность. 

Я, со своей стороны, постараюсь не отставать с переводом.

----------

Это седьмая серия серии Mask-Tutorial, в которой я расскажу вам, как выполнять обработку ошибок в приложении Flask.
<cut />
Для справки ниже приведен список статей этой серии.

<spoiler title="Оглавление">

- [**Глава 1: Привет, мир!**](https://habrahabr.ru/post/346306/)
- [**Глава 2: Шаблоны**](https://habrahabr.ru/post/346340/)
- [**Глава 3: Веб-формы**](https://habrahabr.ru/post/346342/)
- [**Глава 4: База данных **](https://habrahabr.ru/post/346344/)
- [**Глава 5: Пользовательские логины**](https://habrahabr.ru/post/346346/)
- [**Глава 6: Страница профиля и аватары**](https://habrahabr.ru/post/346348/)
- [**Глава 7: Обработка ошибок (Эта статья)**](https://habrahabr.ru/post/346880/)
- Глава 8: Подписчики, контакты и друзья (доступны 23 января 2018 года)
- Глава 9: Разбивка на страницы (доступна 30 января 2018 года)
- Глава 10: Поддержка электронной почты (доступна 6 февраля 2018 года)
- Глава 11: Реконструкция (доступна 13 февраля 2018 года)
- Глава 12: Дата и время (доступно 20 февраля 2018 года)
- Глава 13: I18n и L10n (доступно 27 февраля 2018 года)
- Глава 14: Ajax (доступно 6 марта 2018 года)
- Глава 15: Улучшение структуры приложения (доступно 13 марта 2018 года)
- Глава 16: Полнотекстовый поиск (доступен 20 марта 2018 года)
- Глава 17: Развертывание в Linux (доступно 27 марта 2018 года)
- Глава 18: Развертывание на Heroku (доступно 3 апреля 2018 года)
- Глава 19: Развертывание на Docker контейнерах (доступно 10 апреля 2018 года)
- Глава 20: Магия JavaScript (доступна 17 апреля 2018 года)
- Глава 21: Уведомления пользователей (доступно 24 апреля 2018 года)
- Глава 22: Справочные задания (доступны 1 мая 2018 года)
- Глава 23: Интерфейсы прикладного программирования (API) (доступно 8 мая 2018 г.)

</spoiler>
*Примечание 1: Если вы ищете старые версии данного курса, это [здесь](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy "здесь").*

*Примечание 2: Если вдруг Вы хотели бы выступить в поддержку моей(Мигеля) работы в этом блоге, или просто не имеете терпения дожидаться неделю статьи, я (Мигель Гринберг)предлагаю полную версию данного руководства упакованную электронную книгу или видео. Для получения более подробной информации посетите [learn.miguelgrinberg.com](http://learn.miguelgrinberg.com "learn.miguelgrinberg.com").*

В этой главе я перехожу от кодирования новых функций для моего микроблогического приложения и вместо этого обсужу несколько стратегий борьбы с ошибками, которые неизменно появляются в любом программном проекте. Чтобы проиллюстрировать эту тему, я намеренно допустил ошибку в коде, который я добавил в **главе 6**. Прежде чем продолжить чтение, посмотрите, сможете ли вы его найти!

*Ссылки GitHub для этой главы:*  [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.7), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.7.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.6...v0.7).

# Обработка ошибок в Flask #
Что происходит, когда возникает ошибка в приложении Flask? Лучший способ узнать это - испытать это самому. Запустите приложение и убедитесь, что у вас зарегистрировано не менее двух пользователей. Войдите в систему как один из пользователей, откройте страницу профиля и нажмите ссылку «Изменить». В редакторе профиля попробуйте изменить имя пользователя на существующее имя другого пользователя, который уже зарегистрирован, и попытайтесь применить исправления! Это приведет к появлению страшной страницы "Internal Server Error" ( «Внутренняя ошибка сервера» ):

![](https://habrastorage.org/webt/fe/97/5r/fe975roz261ahsmvdhboliipg4s.png)

В сеансе терминала, на котором запущено приложение, вы видите трассировку стека ошибки. Трассировки стека чрезвычайно полезны при отладке ошибок, поскольку они показывают последовательность вызовов в этом стеке, вплоть до строки, вызвавшей ошибку:
	
	(venv) $ flask run
	 * Serving Flask app "microblog"
	 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
	[2017-09-14 22:40:02,027] ERROR in app: Exception on /edit_profile [POST]
	Traceback (most recent call last):
	  File "/home/miguel/microblog/venv/lib/python3.6/site-packages/sqlalchemy/engine/base.py", line 1182, in _execute_context
	    context)
	  File "/home/miguel/microblog/venv/lib/python3.6/site-packages/sqlalchemy/engine/default.py", line 470, in do_execute
	    cursor.execute(statement, parameters)
	sqlite3.IntegrityError: UNIQUE constraint failed: user.username

Трассировка стека указывает, чем вызвана ошибка. Приложение позволяет пользователю изменять имя пользователя без проверки, что новое имя пользователя не совпадает с другим пользователем, уже находящимся в системе. Ошибка возникает из SQLAlchemy, которая пытается записать новое имя пользователя в базу данных, но база данных отвергает его, потому что столбец имени пользователя определен с unique = True.

Важно, что страница с ошибкой, представленная пользователю, не содержит много информации об ошибке, и это правильно. Я определенно не хочу, чтобы пользователи узнали, что авария была вызвана ошибкой базы данных или какой базой данных я пользуюсь, а также именами таблиц и полей в моей базе данных. Вся эта информация должна быть внутренней.

Есть несколько вещей, которые далеки от идеала. У меня есть страница с ошибкой, которая безобразна и не соответствует макету приложения. У меня также есть важные трассировки стека приложений, которые сбрасываются на терминале, и мне нужно постоянно следить за тем, чтобы я не пропустил никаких ошибок. И, конечно, у меня есть ошибка. Я собираюсь решить все эти проблемы, но сначала поговорим о режиме отладки Flask.

## Режим отладки ##
То, как ошибки обрабатываются выше, отлично подходит для системы, которая работает на production сервере. Если есть ошибка, пользователь получает страницу с неопределенной ошибкой (хотя я собираюсь сделать эту страницу с ошибкой более приятной), а важные данные об ошибке - в выводе сервера или в файле журнала.

Но когда вы разрабатываете приложение, вы можете включить режим отладки, режим, в котором Flask выводит действительно хороший отладчик непосредственно в ваш браузер. Чтобы активировать режим отладки, остановите приложение, а затем установите следующую переменную среды:

    (venv) $ export FLASK_DEBUG=1

Если вы работаете в ОС Microsoft Windows, не забудьте использовать `set` вместо экспорта.

После того, как вы установили FLASK_DEBUG, перезапустите сервер. Строки на вашем терминале будут немного отличаться от того, что вы привыкли видеть:
	
	(venv) microblog2 $ flask run
	 * Serving Flask app "microblog"
	 * Forcing debug mode on
	 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
	 * Restarting with stat
	 * Debugger is active!
	 * Debugger PIN: 177-562-960

Теперь устроим приложению аварийный сбой еще раз, чтобы увидеть интерактивный отладчик в вашем браузере:

![](https://habrastorage.org/webt/64/ec/um/64ecumjr_lxgo9dlmsectaksb1g.png)

Отладчик позволяет развернуть каждый уровень стека и увидеть соответствующий исходный код. Вы также можете открыть Python для любого из фреймов и выполнить любые допустимые выражения Python, например, чтобы проверить значения переменных.

Крайне важно, чтобы вы никогда не запускали приложение Flask в режиме отладки на рабочем сервере. Отладчик позволяет удаленно выполнять код на сервере, поэтому он может стать неожиданным подарком злоумышленнику, который хочет проникнуть в ваше приложение или на ваш сервер. В качестве дополнительной меры безопасности отладчик, запущенный в браузере, закроется, и при первом использовании запросит PIN-код, который вы можете увидеть на выходе команды `flask run`.

Поскольку я говорю о режиме отладки, следует упомянуть про вторую важную функцию, которая включена в режиме отладки - перезагрузка. Это очень полезная функция разработки, которая автоматически перезапускает приложение при изменении исходного файла. Если вы выполните `flask run` в режиме отладки, можно продолжать работать в своем приложении и при каждом сохранении файла, приложение перезапустится, чтобы забрать новый код.

## Пользовательские страницы ошибок ##
Flask предоставляет механизм приложения для создания собственных страниц ошибок, так что вашим пользователям не нужно видеть простые и скучные значения по умолчанию. В качестве примера давайте определим пользовательские страницы ошибок для ошибок HTTP 404 и 500, двух наиболее распространенных. Определение страниц для других ошибок работает одинаково.

Чтобы объявить пользовательский обработчик ошибок, используется декоратор `@errorhandler`. Я собираюсь поместить обработчики ошибок в новый модуль *app/errors.py*.
	
	from flask import render_template
	from app import app, db
	
	@app.errorhandler(404)
	def not_found_error(error):
	    return render_template('404.html'), 404
	
	@app.errorhandler(500)
	def internal_error(error):
	    db.session.rollback()
	    return render_template('500.html'), 500

Функции ошибок работают аналогично функциям просмотра. Для этих двух ошибок я возвращаю содержимое их соответствующих шаблонов. Обратите внимание, что обе функции возвращают второе значение после шаблона, который является номером кода ошибки. Для всех функций представления, которые я создал до сих пор, мне не нужно было добавлять второе возвращаемое значение, потому что по умолчанию 200 (код состояния для успешного завершения) - это то, что я хотел. Сейчас это страницы с ошибками, поэтому я хочу, чтобы код состояния ответа это отражал.

Обработчик ошибок для 500 ошибок может быть вызван после возникновения ошибки базы данных, которая на самом деле была вызвана умышленным случаем дубликата имени пользователя. Чтобы убедиться, что неудачные сеансы базы данных не мешают доступу к базе данных, вызванным шаблоном, я выдаю откат сеанса. Это сбрасывает сеанс в чистое состояние.

Вот шаблон для ошибки 404:
	
	{% extends "base.html" %}
	
	{% block content %}
	    <h1>File Not Found</h1>
	    <p><a href="{{ url_for('index') }}">Back</a></p>
	{% endblock %}

И вот одна из ошибок 500:
	
	{% extends "base.html" %}
	
	{% block content %}
	    <h1>An unexpected error has occurred</h1>
	    <p>The administrator has been notified. Sorry for the inconvenience!</p>
	    <p><a href="{{ url_for('index') }}">Back</a></p>
	{% endblock %}

Оба шаблона наследуют шаблон `base.html`, так что страница с ошибками имеет тот же внешний вид, что и обычные страницы приложения.

Чтобы получить эти обработчики ошибок, зарегистрированные в Flask, мне нужно импортировать новый модуль `app/errors.py` после создания экземпляра приложения:
	
	# ...
	
	from app import routes, models, errors

Если вы установили `FLASK_DEBUG = 0` в сеансе терминала и затем снова вызвали  ошибку повторного имени пользователя, вы увидите более приятную страницу с ошибкой.

![](https://habrastorage.org/webt/ea/cn/vn/eacnvnhobuzutlix1tkqjznxl18.png)

## Отправка ошибок по электронной почте ##
Другая проблема с обработкой ошибок по умолчанию, предоставляемой Flask, заключается в том, что нет уведомлений! Трассировка стека ошибки печатается на терминале, а это означает, что вывод процесса сервера должен контролироваться на обнаружение ошибок. Когда вы запускаете приложение во время разработки, это нормально, но как только приложение будет развернуто на production сервере, никто не будет смотреть на результат, поэтому необходимо создать более надежное решение.

Я думаю, что очень важно, чтобы я активно реагировал на ошибки. Если в production версии приложения возникает ошибка, я хочу знать сразу. Таким образом, моим первым решением будет сконфигурировать Flask для отправки мне сообщения по email сразу после  возникновения ошибки с трассировкой стека ошибки в сообщении электронной почты.

Первым шагом является добавление данных сервера электронной почты в файл конфигурации:
	
	class Config(object):
	    # ...
	    MAIL_SERVER = os.environ.get('MAIL_SERVER')
	    MAIL_PORT = int(os.environ.get('MAIL_PORT') or 25)
	    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS') is not None
	    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
	    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
	    ADMINS = ['your-email@example.com']

Переменные конфигурации для электронной почты соднржат сервер и порт, флаг для включения зашифрованных соединений и необязательное имя пользователя и пароль. Пять переменных конфигурации получены из их сопоставлений переменным среды. Если сервер электронной почты не установлен в среде, то я буду использовать это как знак того, что ошибки электронной почты должны быть отключены. Порт сервера электронной почты также можно указать в переменной среды, но если он не установлен, используется стандартный порт 25. Учетные данные почтового сервера по умолчанию не используются, но могут быть предоставлены при необходимости. Переменная конфигурации `ADMINS` представляет собой список адресов электронной почты, которые будут получать отчеты об ошибках, поэтому ваш собственный адрес электронной почты должен быть в этом списке.

Flask использует пакет `logging` Python для ведения своих журналов, а этот пакет уже имеет возможность отправлять журналы по электронной почте. Все, что мне нужно сделать, чтобы отправлять электронные сообщения, содержащие ошибки, - это добавить экземпляр [SMTPHandler](https://docs.python.org/3.6/library/logging.handlers.html#smtphandler) в объект журнала Flask, которым является `app.logger`:
	
	import logging
	from logging.handlers import SMTPHandler
	
	# ...
	
	if not app.debug:
	    if app.config['MAIL_SERVER']:
	        auth = None
	        if app.config['MAIL_USERNAME'] or app.config['MAIL_PASSWORD']:
	            auth = (app.config['MAIL_USERNAME'], app.config['MAIL_PASSWORD'])
	        secure = None
	        if app.config['MAIL_USE_TLS']:
	            secure = ()
	        mail_handler = SMTPHandler(
	            mailhost=(app.config['MAIL_SERVER'], app.config['MAIL_PORT']),
	            fromaddr='no-reply@' + app.config['MAIL_SERVER'],
	            toaddrs=app.config['ADMINS'], subject='Microblog Failure',
	            credentials=auth, secure=secure)
	        mail_handler.setLevel(logging.ERROR)
	        app.logger.addHandler(mail_handler)

Как видно, я включил регистратор электронной почты только, когда приложение работает без режима отладки, что определено приложением в `app.debug` как `True`, а также когда сервер электронной почты существует в конфигурации.

Настройка почтового регистратора несколько утомительна из-за необходимости обрабатывать дополнительные параметры безопасности, которые присутствуют на многих серверах электронной почты. Но в сущности, вышеприведенный код создает экземпляр `SMTPHandler`, устанавливает его уровень, чтобы он отправлял только сообщения об ошибках, а не предупреждения, информационные или отладочные сообщения и, наконец, прикреплял их к `app.logger` из Flask.

Существует два подхода к проверке работоспособности этой функции. Самый простой способ - использовать SMTP-сервер отладки от Python. Это ложный почтовый сервер, который принимает сообщения электронной почты, но вместо их отправки выводит их на консоль. Чтобы запустить этот сервер, откройте второй сеанс терминала и запустите на нем следующую команду:

    (venv) $ python -m smtpd -n -c DebuggingServer localhost:8025

Чтобы протестировать приложение с этим сервером, вы должны установить `MAIL_SERVER = localhost` и `MAIL_PORT = 8025`. Если вы находитесь в системе Linux или Mac OS, вам, скорее всего, потребуется префикс команды `sudo`, чтобы он мог выполняться с правами администратора. Если вы находитесь в системе Windows, вам может потребоваться открыть окно терминала в качестве администратора. Для этой команды необходимы права администратора, поскольку порты ниже 1024 являются портами только для администратора. В качестве альтернативы вы можете изменить порт на более высокий номер порта, например 5025, и установить переменную `MAIL_PORT` в выбранный вами порт в среде, и это не потребует прав администратора.

Оставьте запущенный SMTP-сервер отладки и вернитесь к своему первому терминалу и установите `export`  `MAIL_SERVER = localhost` и `MAIL_PORT = 8025` (используйте `set` вместо `export` , если вы используете Microsoft Windows). Убедитесь, что для переменной `FLASK_DEBUG` установлено значение `0` или не установлено вообще, так как приложение не будет отправлять электронные письма в режиме отладки.
Запустите приложение и вызовите ошибку SQLAlchemy еще раз, чтобы узнать, как сеанс терминала, на котором работает поддельный почтовый сервер, показывает электронное письмо с полным содержимым стека ошибки.

Второй метод тестирования для этой функции - настроить настоящий почтовый сервер. Ниже приведена конфигурация для использования почтового сервера для учетной записи *Gmail*:
	
	export MAIL_SERVER=smtp.googlemail.com
	export MAIL_PORT=587
	export MAIL_USE_TLS=1
	export MAIL_USERNAME=<your-gmail-username>
	export MAIL_PASSWORD=<your-gmail-password>

Если вы используете Microsoft Windows, не забудьте использовать `set` вместо `export` в каждой из приведенной выше инструкции.

Функции безопасности вашей учетной записи Gmail могут препятствовать приложению отправлять электронную почту через нее, если вы явно не разрешаете  "less secure apps" («менее безопасным приложениям») доступ к вашей учетной записи Gmail. Прочитать об этом можно [здесь](https://support.google.com/accounts/answer/6010255?hl=en), и если вас беспокоит безопасность вашей учетной записи, можно создать вторичную учетную запись, которую настройте только для проверки электронной почты, или  временно включите разрешение для менее безопасных приложений на время запуска этого теста, а затем вернитесь к умолчанию.
	
## Запись лога в файл ##
Получение ошибок по электронной почте полезно, но иногда недостаточно. Есть некоторые случаи сбоя, которые не описываются исключением Python и не являются серьезной проблемой, но они все равно могут быть достаточно интересными для сохранения в целях отладки. По этой причине я также буду поддерживать логфайл для приложения.

Чтобы включить ведение журнала другого обработчика, на этот раз типа `RotatingFileHandler` необходимо включить logger приложения аналогично обработчику электронной почты.
	
	# ...
	from logging.handlers import RotatingFileHandler
	import os
	
	# ...
	
	if not app.debug:
	    # ...
	
	    if not os.path.exists('logs'):
	        os.mkdir('logs')
	    file_handler = RotatingFileHandler('logs/microblog.log', maxBytes=10240,
	                                       backupCount=10)
	    file_handler.setFormatter(logging.Formatter(
	        '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'))
	    file_handler.setLevel(logging.INFO)
	    app.logger.addHandler(file_handler)
	
	    app.logger.setLevel(logging.INFO)
	    app.logger.info('Microblog startup')

Я пишу логфайл с именем `microblog.log` в каталоге *logs*, который я создаю, если он еще не существует.

Класс `RotatingFileHandler` удобен, потому что он переписывает журналы, гарантируя, что файлы журнала не будут слишком большими, если приложение работает в течение длительного времени. В этом случае я ограничиваю размер логфайла 10 КБ, и храню последние десять файлов журнала в качестве резервных копий.

Класс `logging.Formatter` предоставляет настройку формата сообщений журнала. Поскольку эти сообщения отправляются в файл, я хочу, чтобы они содержали как можно больше информации. Поэтому я использую формат, который включает отметку времени, уровень ведения журнала,
сообщение, исходный файл и номер строки, откуда возникла запись в журнале.

Чтобы сделать регистрацию более полезной, я также понижаю уровень ведения журнала до категории `INFO`, как в регистраторе приложений, так и в обработчике файлов. Если вы не знакомы с категориями ведения журнала, это `DEBUG`, `INFO`, `WARNING`,`ERROR` и `CRITICAL` в порядке возрастания степени тяжести.

В качестве первого полезного использования логфайла сервер записывает строку в журнал каждый раз, когда он запускается. Когда приложение запускается на production  сервере, эти записи журнала сообщают вам, когда сервер был перезапущен.

## Исправление дубля имени пользователя ##
Я слишком долго использовал ошибку дублирования имени пользователя. Теперь, когда я показал вам, как подготовить приложение для обработки подобных ошибок, я могу наконец то это исправить.

Если вы помните, `RegistrationForm` уже выполняет проверку для имен пользователей, но требования формы редактирования немного отличаются. Во время регистрации мне нужно убедиться, что имя пользователя, введенное в форму, не существует в базе данных. В форме профиля редактирования я должен выполнить ту же проверку, но с одним исключением. Если пользователь оставляет исходное имя пользователя нетронутым, то проверка должна его разрешить, поскольку это имя пользователя уже назначено этому пользователю. Ниже вы можете увидеть, как я выполнил проверку имени пользователя для этой формы:
	
	class EditProfileForm(FlaskForm):
	    username = StringField('Username', validators=[DataRequired()])
	    about_me = TextAreaField('About me', validators=[Length(min=0, max=140)])
	    submit = SubmitField('Submit')
	
	    def __init__(self, original_username, *args, **kwargs):
	        super(EditProfileForm, self).__init__(*args, **kwargs)
	        self.original_username = original_username
	
	    def validate_username(self, username):
	        if username.data != self.original_username:
	            user = User.query.filter_by(username=self.username.data).first()
	            if user is not None:
	                raise ValidationError('Please use a different username.')


Реализация выполняется в специальном методе проверки, функция super в конструкторе класса, который принимает исходное имя пользователя в качестве аргумента. Это имя пользователя сохраняется как переменная экземпляра и проверяется в методе `validate_username()`. Если имя пользователя, введенное в форму, совпадает с исходным именем пользователя, то нет причин проверять базу данных на наличие дубликатов.

Чтобы использовать этот новый метод проверки, мне нужно добавить исходный аргумент имени пользователя в функцию вида, где создается объект формы:
	
	@app.route('/edit_profile', methods=['GET', 'POST'])
	@login_required
	def edit_profile():
	    form = EditProfileForm(current_user.username)
	    # ...

Теперь ошибка исправлена, и дубликаты в форме профиля редактирования будут предотвращены в большинстве случаев. Это не идеальное решение, поскольку оно может не работать, когда два или несколько процессов одновременно обращаются к базе данных. В этой ситуации *состояние гонки* может привести к валидации, но спустя мгновение при попытке переименования база данных уже была изменена другим процессом и не может переименовать пользователя. Это несколько маловероятно, за исключением очень занятых приложений, у которых много серверных процессов, поэтому я пока не буду беспокоиться об этом.

На этом этапе вы можете попытаться воспроизвести ошибку еще раз, чтобы увидеть, как ее предотвращает метод проверки формы.












