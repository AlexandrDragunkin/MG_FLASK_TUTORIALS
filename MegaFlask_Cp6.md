[blog.miguelgrinberg.com](http://blog.miguelgrinberg.com "blog.miguelgrinberg.com")

# Мега-Учебник Flask, Часть 6: Страница профиля и аватары #
### *Miguel Grinberg* ###

----

Эта статья является переводом шестой части нового издания учебника Мигеля Гринберга, выпуск которого автор планирует завершить в мае 2018.[Прежний перевод](https://habrahabr.ru/post/193242/ "Прежний перевод") давно утратил свою актуальность. 

Я, со своей стороны, постараюсь не отставать с переводом.

----------

Перевел и опубликовал: *Александр Драгункин*

----------

Это шестой выпуск серии Flask Mega-Tutorial, в котором я расскажу вам, как создать страницу профиля пользователя.

Для справки ниже приведен список статей этой серии.


- **Глава 1: Привет, мир!**
- **Глава 2: Шаблоны**
- **Глава 3: Веб-формы**
- **Глава 4: База данных**
- **Глава 5: Пользовательские логины**
- **Глава 6: Страница профиля и аватары (Эта статья)**
- Глава 7: Обработка ошибок (доступно 16 января 2018 года)
- Глава 8: Подписчики, контакты и друзья (доступны 23 января 2018 года)
- Глава 9: Разбивка на страницы (доступна 30 января 2018 года)
- Глава 10: Поддержка электронной почты (доступна 6 февраля 2018 года)
- Глава 11: Реконструкция (доступна 13 февраля 2018 года)
- Глава 12: Дата и время (доступно 20 февраля 2018 года)
- Глава 13: I18n и L10n (доступно 27 февраля 2018 года)
- Глава 14: Ajax (доступно 6 марта 2018 года)
- Глава 15: Улучшение структуры приложения (доступно 13 марта 2018 года)
- Глава 16: Полнотекстовый поиск (доступен 20 марта 2018 года)
- Глава 17: Развертывание в Linux (доступно 27 марта 2018 года)
- Глава 18: Развертывание на Heroku (доступно 3 апреля 2018 года)
- Глава 19: Развертывание на Docker контейнерах (доступно 10 апреля 2018 года)
- Глава 20: Магия JavaScript (доступна 17 апреля 2018 года)
- Глава 21: Уведомления пользователей (доступно 24 апреля 2018 года)
- Глава 22: Справочные задания (доступны 1 мая 2018 года)
- Глава 23: Интерфейсы прикладного программирования (API) (доступно 8 мая 2018 г.)

*Примечание 1: Если вы ищете старые версии данного курса, это [здесь](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy "здесь").*

*Примечание 2: Если вдруг Вы хотели бы выступить в поддержку моей(Мигеля) работы в этом блоге, или просто не имеете терпения дожидаться неделю статьи, я (Мигель Гринберг)предлагаю полную версию данного руководства упакованную электронную книгу или видео. Для получения более подробной информации посетите [learn.miguelgrinberg.com](http://learn.miguelgrinberg.com "learn.miguelgrinberg.com").*

Эта глава будет посвящена добавлению страниц профилей пользователей в приложение. Страница профиля пользователя-это страница, на которой представлена информация о пользователе, как правило, введенной самими пользователями. Я покажу вам, как создавать страницы профилей для всех пользователей динамически, а затем я добавлю небольшой редактор профилей, который пользователи могут использовать для ввода своей информации.

*Ссылки GitHub для этой главы:*  [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.6), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.6.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.5...v0.6).

## Страница профиля пользователя ##

Чтобы создать страницу профиля пользователя, давайте сначала напишем новую функцию просмотра, которая будет отображаться в */user/<имя пользователя>* URL.
	
	@app.route('/user/<username>')
	@login_required
	def user(username):
	    user = User.query.filter_by(username=username).first_or_404()
	    posts = [
	        {'author': user, 'body': 'Test post #1'},
	        {'author': user, 'body': 'Test post #2'}
	    ]
	    return render_template('user.html', user=user, posts=posts)
	
Декоратор `@app.route`, который я использовал для объявления этой функции просмотра, немного отличается от предыдущих. В этом случае у меня есть динамический компонент, который обозначается как компонент URL-адреса `<username>`, который окружен `<`и`>`. Когда маршрут имеет динамический компонент, Flask принимает любой текст в этой части URL-адреса и вызывает функцию просмотра с фактическим текстом в качестве аргумента. Например, если клиентский браузер запрашивает */user/susan* URL, функция `view` будет вызываться с именем пользователя в качестве аргумента, установленным на `«susan»`. Эта функция просмотра будет доступна только для зарегистрированных пользователей, поэтому я добавил обработчик `@login_required` из Flask-Login.

Реализация этой функции просмотра довольно проста. Сначала я пытаюсь загрузить пользователя из базы данных, используя запрос по имени пользователя. Вы уже видели, что запрос базы данных может быть выполнен путем вызова `all()`, если вы хотите получить все результаты, или `first()`, если вы хотите получить только первый результат или `None`, если есть нулевые результаты. В этой функции представления я использую вариант `first()`, называемый `first_or_404(),` который работает точно так же, как `first()`, когда есть результаты, но в случае отсутствия результатов автоматически обратно клиенту отправляется *ошибка 404*. Выполняя запрос таким образом, я не могу проверить, возвратился ли запрос пользователя, потому что, когда имя пользователя не существует в базе данных, функция не вернется, и вместо этого будет вызвано исключение *404*.

Если запрос базы данных не вызывает *ошибку 404*, это означает, что был найден пользователь с указанным именем пользователя. Затем я инициализирую временный список сообщений для этого пользователя, наконец, создаю новый шаблон `user.html`, которому передаю объект пользователя и список сообщений.

Шаблон *user.html* показан ниже:
	
	{% extends "base.html" %}
	
	{% block content %}
	    <h1>User: {{ user.username }}</h1>
	    <hr>
	    {% for post in posts %}
	    <p>
	    {{ post.author.username }} says: <b>{{ post.body }}</b>
	    </p>
	    {% endfor %}
	{% endblock %}
	
Страница профиля завершена, но ссылка на нее не существует нигде на веб-сайте. Чтобы пользователям было проще проверить собственный профиль, я добавлю ссылку на него в панели навигации вверху:

    <div>
      Microblog:
      <a href="{{ url_for('index') }}">Home</a>
      {% if current_user.is_anonymous %}
      <a href="{{ url_for('login') }}">Login</a>
      {% else %}
      <a href="{{ url_for('user', username=current_user.username) }}">Profile</a>
      <a href="{{ url_for('logout') }}">Logout</a>
      {% endif %}
    </div>

Единственное интересное изменение здесь - вызов `url_for()`, который используется для создания ссылки на страницу профиля. Поскольку функция просмотра профиля пользователя принимает динамический аргумент, функция `url_for()` получает значение для него как аргумент ключевого слова. Поскольку это ссылка, которая указывает на профиль пользователя в журнале, я могу использовать `current_user` Flask-Login для генерации правильного URL-адреса.

![](https://habrastorage.org/webt/t5/zb/cj/t5zbcjrvd0bar7zqrdpp6fxdiee.png)

Попробуйте! Нажав ссылку «Профиль» вверху страницы, вы попадете на свою страницу пользователя. На этом этапе нет ссылок, которые будут отображаться на странице профиля других пользователей, но если вы хотите получить доступ к этим страницам, вы можете ввести URL-адрес вручную в адресной строке браузера. Например, если у вас есть пользователь с именем «john», зарегистрированный в вашем приложении, вы можете просмотреть соответствующий профиль пользователя, введя *http://localhost:5000/user/ john* в адресной строке.

## Аватары ##

Я уверен, вы согласитесь с тем, что страницы профиля, которые я только что построил, довольно скучны. Чтобы сделать их более интересными, я собираюсь добавить пользовательские аватары, но вместо того, чтобы иметь дело с возможно большой коллекцией загруженных изображений на сервере, я собираюсь использовать сервис *[Gravatar](http://gravatar.com/)* для предоставления изображений для всех пользователей.

Сервис *Gravatar* очень прост в использовании. Чтобы запросить изображение для данного пользователя, URL-адрес с форматом *https://www.gravatar.com/avatar/<hash>*, где `<hash>` - хеш MD5 адреса электронной почты пользователя. Ниже вы можете увидеть, как получить URL-адрес Gravatar для пользователя с адресом электронной почты `john@example.com`:

    >>> from hashlib import md5
    >>> 'https://www.gravatar.com/avatar/' + md5(b'john@example.com').hexdigest()
    'https://www.gravatar.com/avatar/d4c74594d841139328695756648b6bd6'

Если вы хотите увидеть фактический пример, можно использовать мой собственный URL-адрес Gravatar - *https://www.gravatar.com/avatar/729e26a2a2c7ff24a71958d4aa4e5f35* ( 'https://www.gravatar.com/avatar/4f3699b436c12996ae54771200f21888' ). Вот что Gravatar возвращает для этого URL:

![](https://habrastorage.org/webt/1c/ue/o-/1cueo-lqtgsw7apk7667qvo5jvu.jpeg)

По умолчанию возвращенный размер изображения составляет 80x80 пикселей, но другой размер можно запросить, добавив аргумент `s` в строку запроса URL. Например, чтобы получить мой собственный аватар в виде изображения размером 128x128, URL-адрес: *https://www.gravatar.com/avatar/729e26a2a2c7ff24a71958d4aa4e5f35?s=128*.

Другим интересным аргументом, который может быть передан Gravatar в качестве аргумента строки запроса, является `d`, который определяет, какое изображение Gravatar предоставляет пользователям, у которых нет аватара, зарегистрированного в службе. Мой любимый называется «идентификатор», который возвращает приятный геометрический дизайн, который отличается для каждого письма. Например:

![](https://habrastorage.org/webt/_q/sb/lr/_qsblrgar21tbvvvcxzzzskwr_g.png)

Обратите внимание, что некоторые расширения веб-браузера, такие как Ghostery, блокируют изображения Gravatar, поскольку они считают, что Automattic (владельцы Gravatar) могут определять, какие сайты вы посещаете, на основе запросов, которые они получают для вашего аватара. Если вы не видите аватары в своем браузере, подумайте, что проблема может быть связана с расширением, которое вы установили в своем браузере.

Поскольку аватары связаны с пользователями, имеет смысл добавить логику, которая генерирует URL-адреса аватара для пользовательской модели.
	
	from hashlib import md5
	# ...
	
	class User(UserMixin, db.Model):
	    # ...
	    def avatar(self, size):
	        digest = md5(self.email.lower().encode('utf-8')).hexdigest()
	        return 'https://www.gravatar.com/avatar/{}?d=identicon&s={}'.format(
	            digest, size)

Метод new `avatar()` класса `User` возвращает URL-адрес изображения аватара пользователя, масштабируется до требуемого размера в пикселях. Для пользователей, у которых нет зарегистрированного аватара, будет создано изображение «идентификатор». Чтобы сгенерировать хэш MD5, я сначала конвертирую электронное письмо в нижний регистр, поскольку это требуется службой Gravatar. Затем, поскольку поддержка MD5 в Python работает с байтами, а не с строками, я кодирую строку в виде байтов, прежде чем передавать ее хэш-функции.

Если вы заинтересованы в ознакомлении с другими вариантами, предлагаемыми службой Gravatar, посетите их [сайт документации](https://gravatar.com/site/implement/images).

Следующий шаг - вставить изображения аватара в шаблон профиля пользователя:

	{% extends "base.html" %}
	
	{% block content %}
	    <table>
	        <tr valign="top">
	            <td><img src="{{ user.avatar(128) }}"></td>
	            <td><h1>User: {{ user.username }}</h1></td>
	        </tr>
	    </table>
	    <hr>
	    {% for post in posts %}
	    <p>
	    {{ post.author.username }} says: <b>{{ post.body }}</b>
	    </p>
	    {% endfor %}
	{% endblock %}

Большой плюс заключается в том, что пользовательский класс отвечает за возвращение URL-адресов аватаров.И если в какой-то день я решу, что аватары Gravatar не то, что я хочу, я могу просто переписать метод `avatar()`, чтобы возвращать разные URL-адреса, и все шаблоны начнут показывать новые аватары автоматически.

У меня есть хороший большой аватар в верхней части страницы профиля пользователя, но на самом деле нет причин останавливаться на достигнутом. У меня есть несколько сообщений от пользователя внизу, в которых каждый может иметь маленький аватар. Конечно, для страницы профиля пользователя все сообщения будут иметь один и тот же аватар, но тогда я могу реализовать ту же функциональность на главной странице, а затем каждый пост будет украшен аватаром автора, и это будет выглядеть очень красиво.

Чтобы показать аватары для отдельных сообщений, мне просто нужно сделать еще одно небольшое изменение в шаблоне:
	
	{% extends "base.html" %}
	
	{% block content %}
	    <table>
	        <tr valign="top">
	            <td><img src="{{ user.avatar(128) }}"></td>
	            <td><h1>User: {{ user.username }}</h1></td>
	        </tr>
	    </table>
	    <hr>
	    {% for post in posts %}
	    <table>
	        <tr valign="top">
	            <td><img src="{{ post.author.avatar(36) }}"></td>
	            <td>{{ post.author.username }} says:<br>{{ post.body }}</td>
	        </tr>
	    </table>
	    {% endfor %}
	{% endblock %}

Вот так у Сьюзен, которой нет

![](https://habrastorage.org/webt/g3/c_/1r/g3c_1rhcu2qm20jgqupsmzj1jgi.png)

*(Прим. переводчика)* А вот так с реальным аккаунтом Gravatar.

![](https://habrastorage.org/webt/wg/js/ow/wgjsowjlzhpgzheugu4tgvwfdpa.png)

## Редактор профиля ##

По хорошему пользователям нужно предоставить форму, в которой они могут ввести некоторую информацию о себе. Форма позволит пользователям изменить свой логин и другие данные, а также написать что-то о себе, чтобы быть сохраненным в новом поле *about_me*. Давайте напишем класс для такой формы:
	
	from wtforms import StringField, TextAreaField, SubmitField
	from wtforms.validators import DataRequired, Length
	
	# ...
	
	class EditProfileForm(FlaskForm):
	    username = StringField('Username', validators=[DataRequired()])
	    about_me = TextAreaField('About me', validators=[Length(min=0, max=140)])
	    submit = SubmitField('Submit')

Я использую новый тип поля и новый валидатор в этой форме. Для поля «About» я использую `TextAreaField`, который представляет собой многострочное поле, в котором пользователь может вводить текст. Чтобы проверить это поле, я использую `Length`, который будет следить за тем, чтобы введенный текст находился между 0 и 140 символами,который является пространством, которое я выделил для соответствующего поля в базе данных.

Шаблон, который отображает эту форму, показан ниже:
	
	{% extends "base.html" %}
	
	{% block content %}
	    <h1>Edit Profile</h1>
	    <form action="" method="post">
	        {{ form.hidden_tag() }}
	        <p>
	            {{ form.username.label }}<br>
	            {{ form.username(size=32) }}<br>
	            {% for error in form.username.errors %}
	            <span style="color: red;">[{{ error }}]</span>
	            {% endfor %}
	        </p>
	        <p>
	            {{ form.about_me.label }}<br>
	            {{ form.about_me(cols=50, rows=4) }}<br>
	            {% for error in form.about_me.errors %}
	            <span style="color: red;">[{{ error }}]</span>
	            {% endfor %}
	        </p>
	        <p>{{ form.submit() }}</p>
	    </form>
	{% endblock %}

И, наконец, вот функция, которая связывает все вместе:
	
	from app.forms import EditProfileForm
	
	@app.route('/edit_profile', methods=['GET', 'POST'])
	@login_required
	def edit_profile():
	    form = EditProfileForm()
	    if form.validate_on_submit():
	        current_user.username = form.username.data
	        current_user.about_me = form.about_me.data
	        db.session.commit()
	        flash('Your changes have been saved.')
	        return redirect(url_for('edit_profile'))
	    elif request.method == 'GET':
	        form.username.data = current_user.username
	        form.about_me.data = current_user.about_me
	    return render_template('edit_profile.html', title='Edit Profile',
	                           form=form)

Эта функция просмотра несколько отличается от другой, обрабатывающей форму. Если `validate_on_submit()` возвращает `True`, я копирую данные из формы в объект пользователя, а затем записываю объект в базу данных. Но когда `validate_on_submit()` возвращает `False`, это может быть вызвано двумя разными причинами. Первый, это может быть связано с тем, что браузер просто отправил запрос `GET`, на который мне нужно ответить, предоставив исходную версию шаблона формы. Это также может быть, когда браузер отправляет запрос `POST` с данными формы, но что-то в этих данных является недопустимым. Для этой формы мне нужно рассматривать эти два случая отдельно. Когда форма запрашивается в первый раз с запросом `GET`, я хочу предварительно заполнить поля данными, которые хранятся в базе данных, поэтому мне нужно сделать обратное тому, что я сделал в случае отправки, и переместить данные, хранящиеся в полях пользователя, в форму, поскольку это гарантирует, что эти поля формы имеют текущие данные, хранящиеся для пользователя. Но в случае ошибки проверки я не хочу ничего писать в поля формы, потому что они уже были заполнены *WTForms*. Чтобы различать эти два случая, я проверяю `request.method`, который будет `GET` для первоначального запроса,
и `POST` для отправки, которая не прошла проверку.




